'\"
'\" Copyright (c) 1998 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Notifier.3,v 1.1 1998/10/14 21:09:09 cvsadmin Exp $
'\" 
.so man.macros
.TH Notifier 3 1.0 Jacl "Jacl Library Procedures"
.BS
.SH CLASS
tcl.lang.Notifier -- The event queue and notifier API.

.SH METHODS
.sp
synchronized void \fBdeleteEvents\fR(EventDeleter \fIdeleter\fR)
.sp
synchronized int \fBdoOneEvent\fR(int \fIflags\fR)
.sp
static synchronized Notifier \fBgetNotifierForThread\fR(Thread
\fIthread\fR)
.sp
synchronized void \fBpreserve\fR()
.sp
synchronized void \fBqueueEvent\fR(TclEvent \fIevent\fR, int \fIpos\fR)
.sp
synchronized void \fBrelease\fR()

.SH ARGUMENTS
.AS TclObject "table[]" .
.AP Thread thread
The thread in which the Notifier should run.
.AP EventDeleter deleter
The EventDeleter determines which event in the event queue should be
deleted.
.AP TclEvent event
The event to put into the event queue.
.AP int pos
The position at which the event should be queued.
.AP int flags
What types of events to service.
.BE

.SH DESCRIPTION

The \fBNotifier\fR is the lowest-level part of the Jacl event
system. It is used by higher-level event sources such as file,
JavaBean and timer events. The Notifier manages an event queue that
holds \fBTclEvent\fR objects.

The Jacl \fBNotifier\fR is designed to run in a multi-threaded
environment. Each \fBNotifier\fR instance is associated with a
\fBprimary thread\fR. Any thread can queue (or dequeue) events using
the \fBqueueEvent\fR (or \fBdeleteEvents\fR) call. However, only the
primary thread may process events in the queue using the
\fBdoOneEvent\fR call. Attempts to call \fBdoOneEvent\fR from a
non-primary thread will cause a \fBTclRuntimeError\fR.

This class doesn't have a public constructor and cannot be directly
instantiated. You can get to it only through
\fBNotifier.getNotifierForThread\fR or the \fBgetNotifier\fR method of
the \fBInterp\fR class.

.TP
\fBgetNotifierForThread\fR
This static method returns the \fBNotifier\fR instance whose primary
thread is the given thread. If such an instance does not yet exist, it
is created automatically.
.TP
\fBpreserve\fR, \fBrelease\fR
These two methods maintain a reference count to manage the lifetime of
a Notifier and its corresponding event queue. When a Notifier is
created inside the \fB\fBgetNotifierForThread\fR method, its reference
count is zero. A call to preserve increments the reference count by
one; a call to \fBrelease\fR decrements the reference count by
one. When the reference count goes from one to zero, the Notifier is
disposed -- its event queue is deleted and any left-over events in the
queue will not be processed.
.sp
If a Java module intends to use a Notifier returned by
\fBgetNotifierForThread\fR over one or more method calls, it should
call \fBpreserve\fR immediately after \fBgetNotifierForThread\fR
returns. The module should call \fBrelase\fR when it no longer needs
access to the notifier.
.sp
NOTE: the notifier returned by \fIinterp\fR.\fBgetNotifier\fR will remain
valid as long as the Interpreter is valid. Hence, if a module always
access a notifier via calls to \fIinterp\fR.\fBgetNotifier\fR, it needs not
use the notifier's \fBpreserve\fR and \fBrelease\fR methods.
.TP
\fBqueueEvent\fR
This method puts the \fIevent\fR into the event queue at the position
specified by the \fIpos\fR argument. The \fIpos\fR argument may be one
of the following:
.RS
.TP
\fBTCL.QUEUE_TAIL\fR
Add the event at the back of the queue, so that all other pending
events will be serviced first.  This is almost always the right place
for new events.
.TP
\fBTCL.QUEUE_HEAD\fR
Add the event at the front of the queue, so that it will be serviced
before all other queued events. 
.TP
\fBTCL.QUEUE_MARK\fR
Add the event at the front of the queue, unless there are other events
at the front whose position is \fBTCL.QUEUE_MARK\fR; if so, add the
new event just after all other \fBTCL.QUEUE_MARK\fR events.  This
value of position is used to insert an ordered sequence of events at
the front of the queue, such as a series of Enter and Leave events
synthesized during a grab or ungrab operation in Tk.
.RE
.TP
\fBdeleteEvents\fR
This method provides a way to selectively delete events in the event
queue. It calls \fIdeleter\fR.\fBdeleteEvent\fR for each event in the
queue and deletes those for which \fIdeleter\fR.\fBdeleteEvent\fR
returns 1. Events for which the \fIdeleter\fR returns 0 are left in the
queue.
.TP
\fBdoOneEvent\fR
This method is called in the context of the Notifier's primary thread
to dispatch events in the event queue. If events are found in the
event queue, the \fBprocessEvent\fR method of the first available
event is called. If no event are in the queue, \fBdoOneEvent\fR checks
if there are idle handlers. If there are any, it invokes all of them
and returns. Finally, if no events or idle callbacks have been found,
then \fBdoOneEvent\fR sleeps until an event occurs, calles
\fBprocessEvent\fR the of the event and returns.
.sp
If the \fIflags\fR argument to \fBdoOneEvent\fR is non-zero, it
restricts the kinds of events that will be processed by
\fBdoOneEvent\fR. Flags may be an OR-ed combination of any of the
following bits:
.RS
.TP
\fBTCL.WINDOW_EVENTS\fR
Process window system events.
.TP
\fBTCL.FILE_EVENTS\fR
Process file events.
.TP
\fBTCL.TIMER_EVENTS\fR
Process timer events.
.TP
\fBTCL.IDLE_EVENTS\fR
Process idle callbacks.
.TP
\fBTCL.ALL_EVENTS\fR
Process all kinds of events: equivalent to OR-ing together all of the
above flags or specifying none of them.
.TP
\fBTCL.DONT_WAIT\fR
Don't sleep: process only events that are ready at the time of the
call.
.PP
If any of the flags \fBTCL.WINDOW_EVENTS\fR, \fBTCL.FILE_EVENTS\fR,
\fBTCL.TIMER_EVENTS\fR, or \fBTCL.IDLE_EVENTS\fR is set, then the only
events that will be considered are those for which flags are set.
Setting none of these flags is equivalent to the value
\fBTCL.ALL_EVENTS\fR, which causes all event types to be processed.
If an application has additional event sources then additional flag
values may also be valid, depending on those event sources.
.sp
The \fBTCL.DONT_WAIT\fR flag causes \fBdoOneEvent\fR not to put the
process to sleep: it will check for events but if none are found then
it returns immediately with a return value of 0 to indicate that no
work was done. \fBdoOneEvent\fR will also return 0 without doing
anything if the only alternative is to block forever (this can happen,
for example, if flags is \fBTCL.IDLE_EVENTS\fR and there are no idle
callbacks pending, or if no event handlers or timer handlers exist).
.sp
\fBdoOneEvent\fR may be invoked recursively. For example, it is
possible to invoke \fBdoOneEvent\fR recursively from an event handler
called by \fBdoOneEvent\fR. This sort of operation is useful in some
modal situations, such as when a notification dialog has been popped
up and an application wishes to wait for the user to click a button in
the dialog before doing anything else.
.RE

.SH "EQUIVALENT C FUNCTIONS"
Tcl_QueueEvent, Tcl_DeleteEvents, Tcl_DoOneEvent

.SH "SEE ALSO"
TclEvent, TimerHandler, IdleHandler, EventDeleter, Interp

.SH KEYWORDS
event, notifier, event queue, event sources, file events, timer, idle
