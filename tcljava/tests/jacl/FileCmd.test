# The file tests the FileCmd.java file.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996 by Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: FileCmd.test,v 1.3 2003/02/02 00:59:16 mdejong Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

set file_options {atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}


global env
set platform [testgetplatform]

test filecmd-1.1 {cmdProc} {
    list [catch file msg] $msg
} {1 {wrong # args: should be "file option ?arg ...?"}}
test filecmd-1.2 {cmdProc} {
    list [catch {file x} msg] $msg
} [list 1 "bad option \"x\": must be $file_options"]

# dirname

test filecmd-2.1 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname a b} msg] $msg
} {1 {wrong # args: should be "file dirname name"}}
test filecmd-2.2 {cmdProc: dirname} {
    testsetplatform unix
    file dirname /a/b
} /a
test filecmd-2.3 {cmdProc: dirname} {
    testsetplatform unix
    file dirname {}
} .
test filecmd-2.4 {cmdProc: dirname} {
    testsetplatform mac
    file dirname {}
} :
test filecmd-2.5 {cmdProc: dirname} {
    testsetplatform win
    file dirname {}
} .
test filecmd-2.6 {cmdProc: dirname} {
    testsetplatform unix
    file dirname .def
} .
test filecmd-2.7 {cmdProc: dirname} {
    testsetplatform mac
    file dirname a
} :
test filecmd-2.8 {cmdProc: dirname} {
    testsetplatform win
    file dirname a
} .
test filecmd-2.9 {cmdProc: dirname} {
    testsetplatform unix
    file dirname a/b/c.d
} a/b
test filecmd-2.10 {cmdProc: dirname} {
    testsetplatform unix
    file dirname a/b.c/d
} a/b.c
test filecmd-2.11 {cmdProc: dirname} {
    testsetplatform unix
    file dirname /.
} /
test filecmd-2.12 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname /} msg] $msg
} {0 /}
test filecmd-2.13 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname /foo} msg] $msg
} {0 /}
test filecmd-2.14 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname //foo} msg] $msg
} {0 /}
test filecmd-2.15 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname //foo/bar} msg] $msg
} {0 /foo}
test filecmd-2.16 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname {//foo\/bar/baz}} msg] $msg
} {0 {/foo\/bar}}
test filecmd-2.17 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname {//foo\/bar/baz/blat}} msg] $msg
} {0 {/foo\/bar/baz}}
test filecmd-2.18 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname /foo//} msg] $msg
} {0 /}
test filecmd-2.19 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname ./a} msg] $msg
} {0 .}
test filecmd-2.20 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname a/.a} msg] $msg
} {0 a}
test filecmd-2.21 {cmdProc: dirname} {
    testsetplatform windows
    list [catch {file dirname c:foo} msg] $msg
} {0 c:}
test filecmd-2.22 {cmdProc: dirname} {
    testsetplatform windows
    list [catch {file dirname c:} msg] $msg
} {0 c:}
test filecmd-2.23 {cmdProc: dirname} {
    testsetplatform windows
    list [catch {file dirname c:/} msg] $msg
} {0 c:/}
test filecmd-2.24 {cmdProc: dirname} {
    testsetplatform windows
    list [catch {file dirname {c:\foo}} msg] $msg
} {0 c:/}
test filecmd-2.25 {cmdProc: dirname} {
    testsetplatform windows
    list [catch {file dirname {//foo/bar/baz}} msg] $msg
} {0 //foo/bar}
test filecmd-2.26 {cmdProc: dirname} {
    testsetplatform windows
    list [catch {file dirname {//foo/bar}} msg] $msg
} {0 //foo/bar}
test filecmd-2.27 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname :} msg] $msg
} {0 :}
test filecmd-2.28 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname :Foo} msg] $msg
} {0 :}
test filecmd-2.29 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname Foo:} msg] $msg
} {0 Foo:}
test filecmd-2.30 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname Foo:bar} msg] $msg
} {0 Foo:}
test filecmd-2.31 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname :Foo:bar} msg] $msg
} {0 :Foo}
test filecmd-2.32 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname ::} msg] $msg
} {0 :}
test filecmd-2.33 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname :::} msg] $msg
} {0 ::}
test filecmd-2.34 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname /foo/bar/} msg] $msg
} {0 foo:}
test filecmd-2.35 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname /foo/bar} msg] $msg
} {0 foo:}
test filecmd-2.36 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname /foo} msg] $msg
} {0 foo:}
test filecmd-2.37 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname foo} msg] $msg
} {0 :}
test filecmd-2.38 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname ~/foo} msg] $msg
} {0 ~}
test filecmd-2.39 {cmdProc: dirname} {
    testsetplatform unix
    list [catch {file dirname ~bar/foo} msg] $msg
} {0 ~bar}
test filecmd-2.40 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname ~bar/foo} msg] $msg
} {0 ~bar:}
test filecmd-2.41 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname ~/foo} msg] $msg
} {0 ~:}
test filecmd-2.42 {cmdProc: dirname} {
    testsetplatform mac
    list [catch {file dirname ~:baz} msg] $msg
} {0 ~:}
test filecmd-2.43 {cmdProc: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform unix
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 /home}
test filecmd-2.44 {cmdProc: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "~"
    testsetplatform unix
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 ~}
test filecmd-2.45 {cmdProc: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform windows
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 /home}
test filecmd-2.46 {cmdProc: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform mac
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 home:}

# tail

test filecmd-3.1 {cmdProc: tail} {
    testsetplatform unix
    list [catch {file tail a b} msg] $msg
} {1 {wrong # args: should be "file tail name"}}
test filecmd-3.2 {cmdProc: tail} {
    testsetplatform unix
    file tail /a/b
} b
test filecmd-3.3 {cmdProc: tail} {
    testsetplatform unix
    file tail {}
} {}
test filecmd-3.4 {cmdProc: tail} {
    testsetplatform mac
    file tail {}
} {}
test filecmd-3.5 {cmdProc: tail} {
    testsetplatform win
    file tail {}
} {}
test filecmd-3.6 {cmdProc: tail} {
    testsetplatform unix
    file tail .def
} .def
test filecmd-3.7 {cmdProc: tail} {
    testsetplatform mac
    file tail a
} a
test filecmd-3.8 {cmdProc: tail} {
    testsetplatform win
    file tail a
} a
test filecmd-3.9 {cmdProc: tail} {
    testsetplatform unix
    file ta a/b/c.d
} c.d
test filecmd-3.10 {cmdProc: tail} {
    testsetplatform unix
    file tail a/b.c/d
} d
test filecmd-3.11 {cmdProc: tail} {
    testsetplatform unix
    file tail /.
} .
test filecmd-3.12 {cmdProc: tail} {
    testsetplatform unix
    file tail /
} {}
test filecmd-3.13 {cmdProc: tail} {
    testsetplatform unix
    file tail /foo
} foo
test filecmd-3.14 {cmdProc: tail} {
    testsetplatform unix
    file tail //foo
} foo
test filecmd-3.15 {cmdProc: tail} {
    testsetplatform unix
    file tail //foo/bar
} bar
test filecmd-3.16 {cmdProc: tail} {
    testsetplatform unix
    file tail {//foo\/bar/baz}
} baz
test filecmd-3.17 {cmdProc: tail} {
    testsetplatform unix
    file tail {//foo\/bar/baz/blat}
} blat
test filecmd-3.18 {cmdProc: tail} {
    testsetplatform unix
    file tail /foo//
} foo
test filecmd-3.19 {cmdProc: tail} {
    testsetplatform unix
    file tail ./a
} a
test filecmd-3.20 {cmdProc: tail} {
    testsetplatform unix
    file tail a/.a
} .a
test filecmd-3.21 {cmdProc: tail} {
    testsetplatform windows
    file tail c:foo
} foo
test filecmd-3.22 {cmdProc: tail} {
    testsetplatform windows
    file tail c:
} {}
test filecmd-3.23 {cmdProc: tail} {
    testsetplatform windows
    file tail c:/
} {}
test filecmd-3.24 {cmdProc: tail} {
    testsetplatform windows
    file tail {c:\foo}
} foo
test filecmd-3.25 {cmdProc: tail} {
    testsetplatform windows
    file tail {//foo/bar/baz}
} baz
test filecmd-3.26 {cmdProc: tail} {
    testsetplatform windows
    file tail {//foo/bar}
} {}
test filecmd-3.27 {cmdProc: tail} {
    testsetplatform mac
    file tail :
} :
test filecmd-3.28 {cmdProc: tail} {
    testsetplatform mac
    file tail :Foo
} Foo
test filecmd-3.29 {cmdProc: tail} {
    testsetplatform mac
    file tail Foo:
} {}
test filecmd-3.30 {cmdProc: tail} {
    testsetplatform mac
    file tail Foo:bar
} bar
test filecmd-3.31 {cmdProc: tail} {
    testsetplatform mac
    file tail :Foo:bar
} bar
test filecmd-3.32 {cmdProc: tail} {
    testsetplatform mac
    file tail ::
} ::
test filecmd-3.33 {cmdProc: tail} {
    testsetplatform mac
    file tail :::
} ::
test filecmd-3.34 {cmdProc: tail} {
    testsetplatform mac
    file tail /foo/bar/
} bar
test filecmd-3.35 {cmdProc: tail} {
    testsetplatform mac
    file tail /foo/bar
} bar
test filecmd-3.36 {cmdProc: tail} {
    testsetplatform mac
    file tail /foo
} {}
test filecmd-3.37 {cmdProc: tail} {
    testsetplatform mac
    file tail foo
} foo
test filecmd-3.38 {cmdProc: tail} {
    testsetplatform mac
    file tail ~:foo
} foo
test filecmd-3.39 {cmdProc: tail} {
    testsetplatform mac
    file tail ~bar:foo
} foo
test filecmd-3.40 {cmdProc: tail} {
    testsetplatform mac
    file tail ~bar/foo
} foo
test filecmd-3.41 {cmdProc: tail} {
    testsetplatform mac
    file tail ~/foo
} foo
test filecmd-3.42 {cmdProc: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform unix
    set result [file tail ~]
    set env(HOME) $temp
    set result
} test
test filecmd-3.43 {cmdProc: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "~"
    testsetplatform unix
    set result [file tail ~]
    set env(HOME) $temp
    set result
} {}
test filecmd-3.44 {cmdProc: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform windows
    set result [file tail ~]
    set env(HOME) $temp
    set result
} test
test filecmd-3.45 {cmdProc: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform mac
    set result [file tail ~]
    set env(HOME) $temp
    set result
} test
test filecmd-3.46 {cmdProc: tail} {
    testsetplatform unix
    file tail {f.oo\bar/baz.bat}
} baz.bat
test filecmd-3.47 {cmdProc: tail} {
    testsetplatform windows
    file tail c:foo
} foo
test filecmd-3.48 {cmdProc: tail} {
    testsetplatform windows
    file tail c:
} {}
test filecmd-3.49 {cmdProc: tail} {
    testsetplatform windows
    file tail c:/foo
} foo
test filecmd-3.50 {cmdProc: tail} {
    testsetplatform windows
    file tail {c:/foo\bar}
} bar
test filecmd-3.51 {cmdProc: tail} {
    testsetplatform windows
    file tail {foo\bar}
} bar

# rootname

test filecmd-4.1 {cmdProc: rootname} {
    testsetplatform unix
    list [catch {file rootname a b} msg] $msg
} {1 {wrong # args: should be "file rootname name"}}
test filecmd-4.2 {cmdProc: rootname} {
    testsetplatform unix
    file rootname {}
} {}
test filecmd-4.3 {getExtension rootname} {
    testsetplatform unix
    file ro foo
} foo
test filecmd-4.4 {getExtension rootname} {
    testsetplatform unix
    file rootname foo.
} foo
test filecmd-4.5 {getExtension rootname} {
    testsetplatform unix
    file rootname .foo
} {}
test filecmd-4.6 {getExtension rootname} {
    testsetplatform unix
    file rootname abc.def
} abc
test filecmd-4.7 {getExtension rootname} {
    testsetplatform unix
    file rootname abc.def.ghi
} abc.def
test filecmd-4.8 {getExtension rootname} {
    testsetplatform unix
    file rootname a/b/c.d
} a/b/c
test filecmd-4.9 {getExtension rootname} {
    testsetplatform unix
    file rootname a/b.c/d
} a/b.c/d
test filecmd-4.10 {getExtension rootname} {
    testsetplatform unix
    file rootname a/b.c/
} a/b.c/
test filecmd-4.11 {getExtension rootname} {
    testsetplatform mac
    file ro foo
} foo
test filecmd-4.12 {getExtension rootname} {
    testsetplatform mac
    file rootname {}
} {}
test filecmd-4.13 {getExtension rootname} {
    testsetplatform mac
    file rootname foo.
} foo
test filecmd-4.14 {getExtension rootname} {
    testsetplatform mac
    file rootname .foo
} {}
test filecmd-4.15 {getExtension rootname} {
    testsetplatform mac
    file rootname abc.def
} abc
test filecmd-4.16 {getExtension rootname} {
    testsetplatform mac
    file rootname abc.def.ghi
} abc.def
test filecmd-4.17 {getExtension rootname} {
    testsetplatform mac
    file rootname a:b:c.d
} a:b:c
test filecmd-4.18 {getExtension rootname} {
    testsetplatform mac
    file rootname a:b.c:d
} a:b.c:d
test filecmd-4.19 {getExtension rootname} {
    testsetplatform mac
    file rootname a/b/c.d
} a/b/c
test filecmd-4.20 {getExtension rootname} {
    testsetplatform mac
    file rootname a/b.c/d
} a/b.c/d
test filecmd-4.21 {getExtension rootname} {
    testsetplatform mac
    file rootname /a.b
} /a
test filecmd-4.22 {getExtension rootname} {
    testsetplatform mac
    file rootname foo.c:
} foo.c:
test filecmd-4.23 {getExtension rootname} {
    testsetplatform windows
    file rootname {}
} {}
test filecmd-4.24 {getExtension rootname} {
    testsetplatform windows
    file ro foo
} foo
test filecmd-4.25 {getExtension rootname} {
    testsetplatform windows
    file rootname foo.
} foo
test filecmd-4.26 {getExtension rootname} {
    testsetplatform windows
    file rootname .foo
} {}
test filecmd-4.27 {getExtension rootname} {
    testsetplatform windows
    file rootname abc.def
} abc
test filecmd-4.28 {getExtension rootname} {
    testsetplatform windows
    file rootname abc.def.ghi
} abc.def
test filecmd-4.29 {getExtension rootname} {
    testsetplatform windows
    file rootname a/b/c.d
} a/b/c
test filecmd-4.30 {getExtension rootname} {
    testsetplatform windows
    file rootname a/b.c/d
} a/b.c/d
test filecmd-4.31 {getExtension rootname} {
    testsetplatform windows
    file rootname a\\b.c\\
} a\\b.c\\
test filecmd-4.32 {getExtension rootname} {
    testsetplatform windows
    file rootname a\\b\\c.d
} a\\b\\c
test filecmd-4.33 {getExtension rootname} {
    testsetplatform windows
    file rootname a\\b.c\\d
} a\\b.c\\d
test filecmd-4.34 {getExtension rootname} {
    testsetplatform windows
    file rootname a\\b.c\\
} a\\b.c\\
set num 35
foreach outer { {} a .a a. a.a } {
  foreach inner { {} a .a a. a.a } {
    set thing [format %s/%s $outer $inner]
    test filecmd-4.$num {getExtension rootname and extension options} {
	testsetplatform unix
	format %s%s [file rootname $thing] [file ext $thing]
    } $thing
    set num [expr $num+1]
  }
}

# extension

test filecmd-5.1 {cmdProc: extension} {
    testsetplatform unix
    list [catch {file extension a b} msg] $msg
} {1 {wrong # args: should be "file extension name"}}
test filecmd-5.2 {cmdProc: extension} {
    testsetplatform unix
    file extension {}
} {}
test filecmd-5.3 {getExtension extension} {
    testsetplatform unix
    file ext foo
} {}
test filecmd-5.4 {getExtension extension} {
    testsetplatform unix
    file extension foo.
} .
test filecmd-5.5 {getExtension extension} {
    testsetplatform unix
    file extension .foo
} .foo
test filecmd-5.6 {getExtension extension} {
    testsetplatform unix
    file extension abc.def
} .def
test filecmd-5.7 {getExtension extension} {
    testsetplatform unix
    file extension abc.def.ghi
} .ghi
test filecmd-5.8 {getExtension extension} {
    testsetplatform unix
    file extension a/b/c.d
} .d
test filecmd-5.9 {getExtension extension} {
    testsetplatform unix
    file extension a/b.c/d
} {}
test filecmd-5.10 {getExtension extension} {
    testsetplatform unix
    file extension a/b.c/
} {}
test filecmd-5.11 {getExtension extension} {
    testsetplatform mac
    file ext foo
} {}
test filecmd-5.12 {getExtension extension} {
    testsetplatform mac
    file extension {}
} {}
test filecmd-5.13 {getExtension extension} {
    testsetplatform mac
    file extension foo.
} .
test filecmd-5.14 {getExtension extension} {
    testsetplatform mac
    file extension .foo
} .foo
test filecmd-5.15 {getExtension extension} {
    testsetplatform mac
    file extension abc.def
} .def
test filecmd-5.16 {getExtension extension} {
    testsetplatform mac
    file extension abc.def.ghi
} .ghi
test filecmd-5.17 {getExtension extension} {
    testsetplatform mac
    file extension a:b:c.d
} .d
test filecmd-5.18 {getExtension extension} {
    testsetplatform mac
    file extension a:b.c:d
} {}
test filecmd-5.19 {getExtension extension} {
    testsetplatform mac
    file extension a/b/c.d
} .d
test filecmd-5.20 {getExtension extension} {
    testsetplatform mac
    file extension a/b.c/d
} {}
test filecmd-5.21 {getExtension extension} {
    testsetplatform mac
    file extension /a.b
} .b
test filecmd-5.22 {getExtension extension} {
    testsetplatform mac
    file extension foo.c:
} {}
test filecmd-5.23 {getExtension extension} {
    testsetplatform windows
    file extension {}
} {}
test filecmd-5.24 {getExtension extension} {
    testsetplatform windows
    file ext foo
} {}
test filecmd-5.25 {getExtension extension} {
    testsetplatform windows
    file extension foo.
} .
test filecmd-5.26 {getExtension extension} {
    testsetplatform windows
    file extension .foo
} .foo
test filecmd-5.27 {getExtension extension} {
    testsetplatform windows
    file extension abc.def
} .def
test filecmd-5.28 {getExtension extension} {
    testsetplatform windows
    file extension abc.def.ghi
} .ghi
test filecmd-5.29 {getExtension extension} {
    testsetplatform windows
    file extension a/b/c.d
} .d
test filecmd-5.30 {getExtension extension} {
    testsetplatform windows
    file extension a/b.c/d
} {}
test filecmd-5.31 {getExtension extension} {
    testsetplatform windows
    file extension a\\b.c\\
} {}
test filecmd-5.32 {getExtension extension} {
    testsetplatform windows
    file extension a\\b\\c.d
} .d
test filecmd-5.33 {getExtension extension} {
    testsetplatform windows
    file extension a\\b.c\\d
} {}
test filecmd-5.34 {getExtension extension} {
    testsetplatform windows
    file extension a\\b.c\\
} {}
set num 35
foreach value {a..b a...b a.c..b ..b} result {.b .b .b .b} {
    foreach p {unix mac windows} {
	test filecmd-5.$num {getExtension extension} "
	    testsetplatform $p
	    file extension $value
	" $result
	incr num
    }
}

# pathtype

test filecmd-6.1 {cmdProc: pathtype} {
    testsetplatform unix
    list [catch {file pathtype a b} msg] $msg
} {1 {wrong # args: should be "file pathtype name"}}
test filecmd-6.2 {cmdProc: pathtype} {
    testsetplatform unix
    file pathtype /a
} absolute
test filecmd-6.3 {cmdProc: pathtype} {
    testsetplatform unix
    file p a
} relative
test filecmd-6.4 {cmdProc: pathtype} {
    testsetplatform windows
    file pathtype c:a
} volumerelative
test filecmd-6.5 {getPathType} {
    testsetplatform unix
    file pathtype {}
} relative

# pathtype on unix platform

test filecmd-6.6 {getPathType: unix} {
    testsetplatform unix
    file pathtype /
} absolute
test filecmd-6.7 {getPathType: unix} {
    testsetplatform unix
    file pathtype /foo
} absolute
test filecmd-6.8 {getPathType: unix} {
    testsetplatform unix
    file pathtype ~
} absolute
test filecmd-6.9 {getPathType: unix} {
    testsetplatform unix
    file pathtype ~foo
} absolute
test filecmd-6.10 {getPathType: unix} {
    testsetplatform unix
    file pathtype ~/foo
} absolute
test filecmd-6.11 {getPathType: unix} {
    testsetplatform unix
    file pathtype ./~foo
} relative
test filecmd-6.2 {getPathType: unix} {
    testsetplatform unix
    file pathtype c:/foo
} relative
test filecmd-6.13 {getPathType: unix} {
    testsetplatform unix
    file pathtype foo
} relative

# pathtype on windows platform

test filecmd-6.14 {getPathType: windows} {
    testsetplatform windows
    file pathtype ~
} absolute
test filecmd-6.15 {getPathType: windows} {
    testsetplatform windows
    file pathtype ~foo
} absolute
test filecmd-6.16 {getPathType: windows} {
    testsetplatform windows
    file pathtype ~/foo
} absolute
test filecmd-6.17 {getPathType: windows} {
    testsetplatform windows
    file pathtype ~a/b/c
} absolute

test filecmd-6.18 {getPathType: windows} {
    testsetplatform windows
    file pathtype /
} volumerelative
test filecmd-6.19 {getPathType: windows} {
    testsetplatform windows
    file pathtype \\
} volumerelative
test filecmd-6.20 {getPathType: windows} {
    testsetplatform windows
    file pathtype /foo
} volumerelative
test filecmd-6.21 {getPathType: windows} {
    testsetplatform windows
    file pathtype \\foo
} volumerelative
test filecmd-6.22 {getPathType: windows} {
    testsetplatform windows
    file pathtype //foo/
} volumerelative
test filecmd-6.23 {getPathType: windows} {
    testsetplatform windows
    file pathtype /a/b/c
} volumerelative

test filecmd-6.24 {getWinHomePath: windows} {
    testsetplatform windows
    file pathtype //foo/bar
} absolute
test filecmd-6.25 {getWinHomePath: windows} {
    testsetplatform windows
    file pathtype //a/b
} absolute
test filecmd-6.26 {getWinHomePath: windows} {
    testsetplatform windows
    file pathtype ////ab////cd
} absolute
test filecmd-6.27 {getWinHomePath: windows} {
    testsetplatform windows
    file pathtype //a/b/c/d
} absolute

test filecmd-6.28 {beginsWithLetterColon: windows} {
    testsetplatform windows
    file pathtype c:
} volumerelative
test filecmd-6.29 {beginsWithLetterColon: windows} {
    testsetplatform windows
    file pathtype c:foo
} volumerelative
test filecmd-6.30 {beginsWithLetterColon: windows} {
    testsetplatform windows
    file pathtype c:/
} absolute
test filecmd-6.31 {beginsWithLetterColon: windows} {
    testsetplatform windows
    file pathtype c:\\
} absolute
test filecmd-6.32 {beginsWithLetterColon: windows} {
    testsetplatform windows
    file pathtype c:/foo
} absolute
test filecmd-6.33 {beginsWithLetterColon: windows} {
    testsetplatform windows
    file pathtype c:\\foo
} absolute

test filecmd-6.34 {getPathType: windows} {
    testsetplatform windows
    file pathtype foo
} relative
test filecmd-6.35 {getPathType: windows} {
    testsetplatform windows
    file pathtype ./~foo
} relative
test filecmd-6.36 {getPathType: windows} {
    testsetplatform windows
    file pathtype a/b/c
} relative
test filecmd-6.37 {getPathType: windows} {
    testsetplatform windows
    file pathtype a\\b\\c
} relative

# pathtype on mac platform

test filecmd-6.38 {getPathType: mac, mac-style colon prefixed names} {
    testsetplatform mac
    file pathtype :
} relative
test filecmd-6.39 {getPathType: mac, mac-style colon prefixed names} {
    testsetplatform mac
    file pathtype :foo
} relative
test filecmd-6.40 {getPathType: mac, mac-style colon prefixed names} {
    testsetplatform mac
    file pathtype :foo:bar
} relative
test filecmd-6.41 {getPathType: mac, mac-style colon prefixed names} {
    testsetplatform mac
    file pathtype ::foo:bar
} relative
test filecmd-6.42 {getPathType: mac, mac-style colon prefixed names} {
    testsetplatform mac
    file pathtype :~foo
} relative
test filecmd-6.74 {getPathType: mac, mac-style colon prefixed names} {
    testsetplatform mac
    file pathtype ::::
} relative
test filecmd-6.76 {getPathType: mac, mac-style colon prefixed names} {
    testsetplatform mac
    file pathtype :foo:
} relative

test filecmd-6.78 {getPathType: mac, mac-style names} {
    testsetplatform mac
    file pathtype foo:
} absolute
test filecmd-6.79 {getPathType: mac, mac-style names} {
    testsetplatform mac
    file pathtype foo:bar
} absolute
test filecmd-6.80 {getPathType: mac, mac-style names} {
    testsetplatform mac
    file pathtype foo:bar:
} absolute
test filecmd-6.81 {getPathType: mac, mac-style names} {
    testsetplatform mac
    file pathtype /:
} absolute
test filecmd-6.82 {getPathType: mac, mac-style names} {
    testsetplatform mac
    file pathtype /foo:
} absolute
test filecmd-6.83 {getPathType: mac, mac-style names} {
    testsetplatform mac
    file pathtype foo/bar:
} absolute

test filecmd-6.43 {getPathType: mac, tilde prefixed names} {
    testsetplatform mac
    file pathtype ~
} absolute
test filecmd-6.44 {getPathType: mac, tilde prefixed names} {
    testsetplatform mac
    file pathtype ~:
} absolute
test filecmd-6.45 {getPathType: mac, tilde prefixed names} {
    testsetplatform mac
    file pathtype ~:foo
} absolute
test filecmd-6.46 {getPathType: mac, tilde prefixed names} {
    testsetplatform mac
    file pathtype ~foo
} absolute
test filecmd-6.47 {getPathType: mac, tilde prefixed names} {
    testsetplatform mac
    file pathtype ~foo:
} absolute
test filecmd-6.48 {getPathType: mac, tilde prefixed names} {
    testsetplatform mac
    file pathtype ~/
} absolute
test filecmd-6.49 {getPathType: mac, tilde names} {
    testsetplatform mac
    file pathtype ~/foo
} absolute

test filecmd-6.50 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /
} relative
test filecmd-6.51 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /////
} relative
test filecmd-6.52 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /.
} relative
test filecmd-6.53 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype ////.
} relative
test filecmd-6.54 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /..
} relative
test filecmd-6.55 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype ///..
} relative
test filecmd-6.56 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /./
} relative
test filecmd-6.57 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /./..//.//..///.///.
} relative
test filecmd-6.58 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /./..//.//..///.///..
} relative
test filecmd-6.59 {getDegenerateUnixPath: mac, degenerate names} {
    testsetplatform mac
    file pathtype /./..//.//..///.///..////
} relative

test filecmd-6.60 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype /foo
} absolute
test filecmd-6.61 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype /./foo
} absolute
test filecmd-6.62 {getDegenerateUnixPath:: mac, unix-style names} {
    testsetplatform mac
    file pathtype /..//./foo
} absolute
test filecmd-6.63 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype /..//.foo
} absolute
test filecmd-6.64 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype /foo/bar
} absolute
test filecmd-6.64 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype /...
} absolute
test filecmd-6.65 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype /.../
} absolute
test filecmd-6.66 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype /./..//.//..///.../..
} absolute

test filecmd-6.67 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype foo
} relative
test filecmd-6.68 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype .
} relative
test filecmd-6.69 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype ./
} relative
test filecmd-6.70 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype ../
} relative
test filecmd-6.71 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype ./././//
} relative
test filecmd-6.72 {getDegenerateUnixPath: mac, unix-style names} {
    testsetplatform mac
    file pathtype ../..///.
} relative

# split general tests

test filecmd-7.1 {cmdProc: split} {
    testsetplatform unix
    list [catch {file split a b} msg] $msg
} {1 {wrong # args: should be "file split name"}}
test filecmd-7.2 {cmdProc: split} {
    testsetplatform unix
    file split a
} a
test filecmd-7.3 {cmdProc: split} {
    testsetplatform unix
    file split a/b
} {a b}
test filecmd-7.4 {splitPath: unix} {
    testsetplatform unix
    file split {}
} {}

# split mac platform: relatvie mac-style pathes

test filecmd-7.5 {splitPath: mac} {
    testsetplatform mac
    file split :
} {:}
test filecmd-7.6 {splitPath: mac} {
    testsetplatform mac
    file split ::
} {::}
test filecmd-7.7 {splitPath: mac} {
    testsetplatform mac
    file split :::
} {:: ::}
test filecmd-7.8 {splitPath: mac} {
    testsetplatform mac
    file split :a
} {a}
test filecmd-7.9 {splitPath: mac} {
    testsetplatform mac
    file split :a:
} {a}
test filecmd-7.10 {splitPath: mac} {
    testsetplatform mac
    file split :a:b:c
} {a b c}
test filecmd-7.11 {splitPath: mac} {
    testsetplatform mac
    file split :a::
} {a ::}
test filecmd-7.12 {splitPath: mac} {
    testsetplatform mac
    file split :a::b:
} {a :: b}
test filecmd-7.13 {splitPath: mac} {
    testsetplatform mac
    file split :a:::
} {a :: ::}
test filecmd-7.14 {splitPath: mac} {
    testsetplatform mac
    file split :.
} {.}
test filecmd-7.15 {splitPath: mac} {
    testsetplatform mac
    file split :a:.:..
} {a . ..}
test filecmd-7.16 {splitPath: mac} {
    testsetplatform mac
    file split :~
} {:~}
test filecmd-7.17 {splitPath: mac} {
    testsetplatform mac
    file split :~foo
} {:~foo}
test filecmd-7.18 {splitPath: mac} {
    testsetplatform mac
    file split :~foo:bar
} {:~foo bar}
test filecmd-7.19 {splitPath: mac} {
    testsetplatform mac
    file split :foo:~bar:baz
} {foo :~bar baz}
test filecmd-7.20 {splitPath: mac} {
    testsetplatform mac
    file split :a/b
} {:a/b}
test filecmd-7.21 {splitPath: mac} {
    testsetplatform mac
    file split :a/b:
} {:a/b}
test filecmd-7.22 {splitPath: mac} {
    testsetplatform mac
    file split :a/b:c
} {:a/b c}
test filecmd-7.23 {splitPath: mac} {
    testsetplatform mac
    file split :c:a/b:d
} {:c :a/b d}
test filecmd-7.24 {splitPath: mac} {
    testsetplatform mac
    file split :c:a/b:d:e/f
} {:c :a/b :d :e/f}
test filecmd-7.25 {splitPath: mac} {
    testsetplatform mac
    file split :c:a/b:~foo
} {:c :a/b :~foo}
test filecmd-7.26 {splitPath: mac} {
    testsetplatform mac
    file split :c:~foo:a/b
} {:c :~foo :a/b}
test filecmd-7.27 {splitPath: mac} {
    testsetplatform mac
    file split :c:a/b:foo:~bar:baz
} {:c :a/b foo :~bar baz}

# split mac platform: absolute mac-style pathes

test filecmd-7.28 {splitPath: mac} {
    testsetplatform mac
    file split a:
} {a:}
test filecmd-7.29 {splitPath: mac} {
    testsetplatform mac
    file split a:b:c
} {a: b c}
test filecmd-7.30 {splitPath: mac} {
    testsetplatform mac
    file split a::
} {a: ::}
test filecmd-7.31 {splitPath: mac} {
    testsetplatform mac
    file split a::b:
} {a: :: b}
test filecmd-7.32 {splitPath: mac} {
    testsetplatform mac
    file split a:::
} {a: :: ::}
test filecmd-7.33 {splitPath: mac} {
    testsetplatform mac
    file split .:
} {.:}
test filecmd-7.34 {splitPath: mac} {
    testsetplatform mac
    file split a:.:..
} {a: . ..}
test filecmd-7.35 {splitPath: mac} {
    testsetplatform mac
    file split ~:
} {~:}
test filecmd-7.36 {splitPath: mac} {
    testsetplatform mac
    file split ~foo:bar
} {~foo: bar}
test filecmd-7.37 {splitPath: mac} {
    testsetplatform mac
    file split foo:~bar:baz
} {foo: :~bar baz}
test filecmd-7.38 {splitPath: mac} {
    testsetplatform mac
    file split /:
} {/:}
test filecmd-7.39 {splitPath: mac} {
    testsetplatform mac
    file split ~/:
} {~/:}
test filecmd-7.40 {splitPath: mac} {
    testsetplatform mac
    file split /a:b
} {/a: b}
test filecmd-7.41 {splitPath: mac} {
    testsetplatform mac
    file split a/b:
} {a/b:}
test filecmd-7.42 {splitPath: mac} {
    testsetplatform mac
    file split a/b:c
} {a/b: c}
test filecmd-7.43 {splitPath: mac} {
    testsetplatform mac
    file split c:a/b:d
} {c: :a/b d}
test filecmd-7.44 {splitPath: mac} {
    testsetplatform mac
    file split c:a/b:d:e/f
} {c: :a/b :d :e/f}
test filecmd-7.45 {splitPath: mac} {
    testsetplatform mac
    file split c:a/b:~foo
} {c: :a/b :~foo}
test filecmd-7.46 {splitPath: mac} {
    testsetplatform mac
    file split c:~foo:a/b
} {c: :~foo :a/b}
test filecmd-7.47 {splitPath: mac} {
    testsetplatform mac
    file split c:a/b:foo:~bar:baz
} {c: :a/b foo :~bar baz}

# split mac platform: degenerate unix pathes

test filecmd-7.46 {splitPath: mac} {
    testsetplatform mac
    file split /
} {:/}
test filecmd-7.47 {splitPath: mac} {
    testsetplatform mac
    file split /..
} {:/..}
test filecmd-7.48 {splitPath: mac} {
    testsetplatform mac
    file split //.//.././
} {://.//.././}

# split mac platform: absolute unix pathes

test filecmd-7.49 {splitPath: mac} {
    testsetplatform mac
    file split /foo
} {foo:}
test filecmd-7.50 {splitPath: mac} {
    testsetplatform mac
    file split /a/b
} {a: b}
test filecmd-7.51 {splitPath: mac} {
    testsetplatform mac
    file split /a/b/foo
} {a: b foo}
test filecmd-7.52 {splitPath: mac} {
    testsetplatform mac
    file split //foo
} {foo:}
test filecmd-7.53 {splitPath: mac} {
    testsetplatform mac
    file split /../bar
} {bar:}
test filecmd-7.54 {splitPath: mac} {
    testsetplatform mac
    file split /./bar
} {bar:}
test filecmd-7.55 {splitPath: mac} {
    testsetplatform mac
    file split //.//.././bar
} {bar:}
test filecmd-7.56 {splitPath: mac} {
    testsetplatform mac
    file split /a/./..
} {a: : ::}
test filecmd-7.57 {splitPath: mac} {
    testsetplatform mac
    file split /~foo
} {~foo:}
test filecmd-7.58 {splitPath: mac} {
    testsetplatform mac
    file split /~
} {~:}
test filecmd-7.59 {splitPath: mac} {
    testsetplatform mac
    file split /~foo/bar
} {~foo: bar}
test filecmd-7.60 {splitPath: mac} {
    testsetplatform mac
    file split /foo/~bar/baz
} {foo: :~bar baz}

# split mac platform: relative and tilde prefixed unix pathes

test filecmd-7.61 {splitPath: mac} {
    testsetplatform mac
    file split foo
} {foo}
test filecmd-7.62 {splitPath: mac} {
    testsetplatform mac
    file split a/b
} {a b}
test filecmd-7.63 {splitPath: mac} {
    testsetplatform mac
    file split a/b/c/
} {a b c}
test filecmd-7.64 {splitPath: mac} {
    testsetplatform mac
    file split foo//bar///
} {foo bar}
test filecmd-7.65 {splitPath: mac} {
    testsetplatform mac
    file split ./foo/..
} {: foo ::}
test filecmd-7.66 {splitPath: mac} {
    testsetplatform mac
    file split ../foo/./
} {:: foo :}
test filecmd-7.67 {splitPath: mac} {
    testsetplatform mac
    file split .
} {:}
test filecmd-7.68 {splitPath: mac} {
    testsetplatform mac
    file split ..
} {::}
test filecmd-7.69 {splitPath: mac} {
    testsetplatform mac
    file split ././
} {: :}
test filecmd-7.70 {splitPath: mac} {
    testsetplatform mac
    file split ././.
} {: : :}
test filecmd-7.71 {splitPath: mac} {
    testsetplatform mac
    file split ../
} {::}
test filecmd-7.72 {splitPath: mac} {
    testsetplatform mac
    file split ../..
} {:: ::}
test filecmd-7.73 {splitPath: mac} {
    testsetplatform mac
    file split ~/foo
} {~: foo}
test filecmd-7.74 {splitPath: mac} {
    testsetplatform mac
    file split ~foo
} {~foo:}
test filecmd-7.75 {splitPath: mac} {
    testsetplatform mac
    file split ~
} {~:}
test filecmd-7.76 {splitPath: mac} {
    testsetplatform mac
    file split foo
} {foo}
test filecmd-7.77 {splitPath: mac} {
    testsetplatform mac
    file split ~/
} {~:}
test filecmd-7.78 {splitPath: mac} {
    testsetplatform mac
    file split ~foo/~bar
} {~foo: :~bar}
test filecmd-7.79 {splitPath: mac} {
    testsetplatform mac
    file split ~foo/bar
} {~foo: bar}
test filecmd-7.80 {splitPath: mac} {
    testsetplatform mac
    file split ~foo/~bar///../~baz
} {~foo: :~bar :: :~baz}
test filecmd-7.81 {splitPath: mac} {
    testsetplatform mac
    file split foo/bar~/baz
} {foo bar~ baz}
test filecmd-7.82 {splitPath: mac} {
    testsetplatform mac
    file split foo/~bar~/baz
} {foo :~bar~ baz}

# split unix platform

test filecmd-7.83 {splitPath: unix} {
    testsetplatform unix
    file split /
} {/}
test filecmd-7.84 {splitPath: unix} {
    testsetplatform unix
    file split /foo
} {/ foo}
test filecmd-7.85 {splitPath: unix} {
    testsetplatform unix
    file split /foo/bar
} {/ foo bar}
test filecmd-7.86 {splitPath: unix} {
    testsetplatform unix
    file split /foo/bar/baz
} {/ foo bar baz}
test filecmd-7.87 {splitPath: unix} {
    testsetplatform unix
    file split foo/bar
} {foo bar}
test filecmd-7.88 {splitPath: unix} {
    testsetplatform unix
    file split ./foo/bar
} {. foo bar}
test filecmd-7.89 {splitPath: unix} {
    testsetplatform unix
    file split /foo/../././foo/bar
} {/ foo .. . . foo bar}
test filecmd-7.90 {splitPath: unix} {
    testsetplatform unix
    file split ../foo/bar
} {.. foo bar}
test filecmd-7.91 {splitPath: unix} {
    testsetplatform unix
    file split .
} {.}
test filecmd-7.92 {splitPath: unix} {
    testsetplatform unix
    file split ../
} {..}
test filecmd-7.93 {splitPath: unix} {
    testsetplatform unix
    file split ../..
} {.. ..}
test filecmd-7.94 {splitPath: unix} {
    testsetplatform unix
    file split //foo
} {/ foo}
test filecmd-7.95 {splitPath: unix} {
    testsetplatform unix
    file split foo//bar
} {foo bar}
test filecmd-7.96 {splitPath: unix} {
    testsetplatform unix
    file split ~foo
} {~foo}
test filecmd-7.97 {splitPath: unix} {
    testsetplatform unix
    file split ~foo/~bar
} {~foo ./~bar}
test filecmd-7.98 {splitPath: unix} {
    testsetplatform unix
    file split ~foo/~bar/~baz
} {~foo ./~bar ./~baz}
test filecmd-7.99 {splitPath: unix} {
    testsetplatform unix
    file split foo/bar~/baz
} {foo bar~ baz}
test filecmd-7.100 {splitPath: unix} {
    testsetplatform unix
    file split foo/~bar~/baz
} {foo ./~bar~ baz}

# split windows platform: relative pathes

test filecmd-7.101 {splitPath: win} {
    testsetplatform win
    file split /
} {/}
test filecmd-7.102 {splitPath: win} {
    testsetplatform win
    file split /foo
} {/ foo}
test filecmd-7.103 {splitPath: win} {
    testsetplatform win
    file split /foo/bar
} {/ foo bar}
test filecmd-7.104 {splitPath: win} {
    testsetplatform win
    file split /foo/bar/baz
} {/ foo bar baz}
test filecmd-7.105 {splitPath: win} {
    testsetplatform win
    file split foo/bar
} {foo bar}
test filecmd-7.106 {splitPath: win} {
    testsetplatform win
    file split ./foo/bar
} {. foo bar}
test filecmd-7.107 {splitPath: win} {
    testsetplatform win
    file split /foo/../././foo/bar
} {/ foo .. . . foo bar}
test filecmd-7.108 {splitPath: win} {
    testsetplatform win
    file split ../foo/bar
} {.. foo bar}
test filecmd-7.109 {splitPath: win} {
    testsetplatform win
    file split .
} {.}
test filecmd-7.110 {splitPath: win} {
    testsetplatform win
    file split ../
} {..}
test filecmd-7.111 {splitPath: win} {
    testsetplatform win
    file split ../..
} {.. ..}
test filecmd-7.112 {splitPath: win} {
    testsetplatform win
    file split //foo
} {/ foo}
test filecmd-7.113 {splitPath: win} {
    testsetplatform win
    file split //foo/
} {/ foo}
test filecmd-7.114 {splitPath: win} {
    testsetplatform win
    file split abc
} {abc}
test filecmd-7.115 {splitPath: win} {
    testsetplatform win
    file split abc/ 
} {abc}
test filecmd-7.116 {splitPath: win} {
    testsetplatform win
    file split abc/def/ghi/jkl
} {abc def ghi jkl}
test filecmd-7.117 {splitPath: win} {
    testsetplatform win
    file split abc///def/ghi//jkl///
} {abc def ghi jkl}

# split windows platform: absolute pathes

test filecmd-7.118 {getWinHomePath: win} {
    testsetplatform win
    file split /\\/foo//bar
} {//foo/bar}
test filecmd-7.119 {getWinHomePath: win} {
    testsetplatform win
    file split \\\\foo\\bar
} {//foo/bar}
test filecmd-7.120 {getWinHomePath: win} {
    testsetplatform win
    file split \\\\foo\\bar/baz
} {//foo/bar baz}
test filecmd-7.121 {getWinHomePath: win} {
    testsetplatform win
    file split //a/b
} {//a/b}
test filecmd-7.122 {getWinHomePath: win} {
    testsetplatform win
    file split //a/b/
} {//a/b}
test filecmd-7.123 {getWinHomePath: win} {
    testsetplatform win
    file split //a/b/c
} {//a/b c}
test filecmd-7.124 {getWinHomePath: win} {
    testsetplatform win
    file split //a/~b/c
} {//a/~b c}
test filecmd-7.125 {splitPath: win} {
    testsetplatform win
    file split //a/b/~c
} {//a/b ./~c}

test filecmd-7.126 {splitPath: win} {
    testsetplatform win
    file split c:
} {c:}
test filecmd-7.127 {splitPath: win} {
    testsetplatform win
    file split c:foo
} {c: foo}
test filecmd-7.128 {splitPath: win} {
    testsetplatform win
    file split c:/
} {c:/}
test filecmd-7.129 {splitPath: win} {
    testsetplatform win
    file split c:\\
} {c:/}
test filecmd-7.130 {splitPath: win} {
    testsetplatform win
    file split c:/foo
} {c:/ foo}
test filecmd-7.131 {splitPath: win} {
    testsetplatform win
    file split c:/./..
} {c:/ . ..}

test filecmd-7.132 {splitPath: win} {
    testsetplatform win
    file split ~
} {~}
test filecmd-7.133 {splitPath: win} {
    testsetplatform win
    file split ~foo
} {~foo}
test filecmd-7.134 {splitPath: win} {
    testsetplatform win
    file split ~foo/~bar
} {~foo ./~bar}
test filecmd-7.135 {splitPath: win} {
    testsetplatform win
    file split ~foo/~bar/~baz
} {~foo ./~bar ./~baz}
test filecmd-7.136 {splitPath: win} {
    testsetplatform win
    file split foo/bar~/~baz/fuz
} {foo bar~ ./~baz fuz}
test filecmd-7.137 {splitPath: win} {
    testsetplatform win
    file split c:~foo
} {c: ./~foo}

# join general tests

test filecmd-8.1 {cmdProc: split} {
    testsetplatform unix
    list [catch {file join} msg] $msg
} {1 {wrong # args: should be "file join name ?name ...?"}}
test filecmd-8.2 {cmdProc: join} {
    testsetplatform unix
    file join {}
} {}
test filecmd-8.3 {cmdProc: join} {
    testsetplatform unix
    file join a
} a
test filecmd-8.4 {cmdProc: join} {
    testsetplatform unix
    file join a b
} a/b
test filecmd-8.5 {cmdProc: join} {
    testsetplatform unix
    file join a b c d
} a/b/c/d

# join unix platform

test filecmd-8.6 {joinPath: unix} {
    testsetplatform unix
    file join {} a {}
} a
test filecmd-8.7 {joinPath: unix} {
    testsetplatform unix
    file join a b c
} {a/b/c}
test filecmd-8.8 {joinPath: unix} {
    testsetplatform unix
    file join a b/c d
} {a/b/c/d}
test filecmd-8.9 {joinPath: unix} {
    testsetplatform unix
    file join a b///c d
} {a/b/c/d}
test filecmd-8.10 {joinPath: unix} {
    testsetplatform unix
    file join a b///
} {a/b}
test filecmd-8.11 {joinPath: unix} {
    testsetplatform unix
    file join a b/// c
} {a/b/c}
test filecmd-8.12 {joinPath: unix} {
    testsetplatform unix
    file join ./~
} {./~}
test filecmd-8.13 {joinPath: unix} {
    testsetplatform unix
    file join ./~a
} {./~a}
test filecmd-8.14 {joinPath: unix} {
    testsetplatform unix
    file join .///~a
} {./~a}
test filecmd-8.15 {joinPath: unix} {
    testsetplatform unix
    file join ./~/
} {./~}
test filecmd-8.16 {joinPath: unix} {
    testsetplatform unix
    file join a ./~b c
} {a/~b/c}
test filecmd-8.17 {joinPath: unix} {
    testsetplatform unix
    file join a b./~c d
} {a/b./~c/d}
test filecmd-8.18 {joinPath: unix} {
    testsetplatform unix
    file join a .//~b c
} {a/./~b/c}
test filecmd-8.19 {joinPath: unix} {
    testsetplatform unix
    file join a ../~b c
} {a/../~b/c}

test filecmd-8.20 {joinPath: unix} {
    testsetplatform unix
    file join /
} {/}
test filecmd-8.21 {joinPath: unix} {
    testsetplatform unix
    file join / / /
} {/}
test filecmd-8.22 {joinPath: unix} {
    testsetplatform unix
    file join / ///
} {/}
test filecmd-8.23 {joinPath: unix} {
    testsetplatform unix
    file join / a
} {/a}
test filecmd-8.24 {joinPath: unix} {
    testsetplatform unix
    file join /a c /b d
} {/b/d}
test filecmd-8.25 {joinPath: unix} {
    testsetplatform unix
    file join //a b
} {/a/b}
test filecmd-8.26 {joinPath: unix} {
    testsetplatform unix
    file join /// a b
} {/a/b}
test filecmd-8.27 {joinPath: unix} {
    testsetplatform unix
    file join //a/b c
} {/a/b/c}
test filecmd-8.28 {joinPath: unix} {
    testsetplatform unix
    file join foo //a/b c
} {/a/b/c}
test filecmd-8.29 {joinPath: unix} {
    testsetplatform unix
    file join a ///b c
} {/b/c}
test filecmd-8.30 {joinPath: unix} {
    testsetplatform unix
    file join /a/ b
} {/a/b}
test filecmd-8.31 {joinPath: unix} {
    testsetplatform unix
    file join /a// b
} {/a/b}
test filecmd-8.32 {joinPath: unix} {
    testsetplatform unix
    file join /a/./../. b
} {/a/./.././b}

test filecmd-8.33 {joinPath: unix} {
    testsetplatform unix
    file join ~
} {~}
test filecmd-8.34 {joinPath: unix} {
    testsetplatform unix
    file join ~ a
} {~/a}
test filecmd-8.35 {joinPath: unix} {
    testsetplatform unix
    file join ~a ~b c
} {~b/c}
test filecmd-8.36 {joinPath: unix} {
    testsetplatform unix
    file join ./~a ~b
} {~b}
test filecmd-8.37 {joinPath: unix} {
    testsetplatform unix
    file join ./~a ./~b
} {./~a/~b}
test filecmd-8.38 {joinPath: unix} {
    testsetplatform unix
    file join a . b
} {a/./b}
test filecmd-8.39 {joinPath: unix} {
    testsetplatform unix
    file join a . ./~b
} {a/./~b}

# join windows platform: relative pathes

test filecmd-8.40 {joinPath: win} {
    testsetplatform win
    file join {} a {}
} a
test filecmd-8.41 {joinPath: win} {
    testsetplatform win
    file join a b c
} {a/b/c}
test filecmd-8.42 {joinPath: win} {
    testsetplatform win
    file join a b/c d
} {a/b/c/d}
test filecmd-8.43 {joinPath: win} {
    testsetplatform win
    file join a b///c d
} {a/b/c/d}
test filecmd-8.44 {joinPath: win} {
    testsetplatform win
    file join a b///
} {a/b}
test filecmd-8.45 {joinPath: win} {
    testsetplatform win
    file join a b/// c
} {a/b/c}
test filecmd-8.46 {joinPath: win} {
    testsetplatform win
    file join ./~
} {./~}
test filecmd-8.47 {joinPath: win} {
    testsetplatform win
    file join ./~a
} {./~a}
test filecmd-8.48 {joinPath: win} {
    testsetplatform win
    file join .///~a
} {./~a}
test filecmd-8.49 {joinPath: win} {
    testsetplatform win
    file join ./~/
} {./~}
test filecmd-8.50 {joinPath: win} {
    testsetplatform win
    file join a ./~b c
} {a/~b/c}
test filecmd-8.51 {joinPath: win} {
    testsetplatform win
    file join a b./~c d
} {a/b./~c/d}
test filecmd-8.52 {joinPath: win} {
    testsetplatform win
    file join a .//~b c
} {a/./~b/c}
test filecmd-8.53 {joinPath: win} {
    testsetplatform win
    file join a ../~b c
} {a/../~b/c}
test filecmd-8.54 {joinPath: win} {
    testsetplatform win
    file join a bcd: e
} {a/bcd:e}
test filecmd-8.55 {joinPath: win} {
    testsetplatform win
    file join a b/c: d
} {a/b/c:d}
test filecmd-8.56 {joinPath: win} {
    testsetplatform win
    file join a b///: c
} {a/b/:c}
test filecmd-8.57 {joinPath: win} {
    testsetplatform win
    file join a : b
} {a/:b}
test filecmd-8.58 {joinPath: win} {
    testsetplatform win
    file join a ::: b
} {a/:::b}
test filecmd-8.59 {joinPath: win} {
    testsetplatform win
    file join foo . bar
} {foo/./bar}
test filecmd-8.60 {joinPath: win} {
    testsetplatform win
    file join foo .. bar
} {foo/../bar}
test filecmd-8.61 {joinPath: win} {
    testsetplatform win
    file join foo/./bar
} {foo/./bar}

# join windows platform: absolute pathes

test filecmd-8.62 {joinPath: win} {
    testsetplatform win
    file join /
} {/}
test filecmd-8.63 {joinPath: win} {
    testsetplatform win
    file join / /// /
} {/}
test filecmd-8.64 {joinPath: win} {
    testsetplatform win
    file join "" / "" /
} {/}
test filecmd-8.65 {joinPath: win} {
    testsetplatform win
    file join /a
} {/a}
test filecmd-8.66 {joinPath: win} {
    testsetplatform win
    file join /a b
} {/a/b}
test filecmd-8.67 {joinPath: win} {
    testsetplatform win
    file join /a /b
} {/b}
test filecmd-8.68 {joinPath: win} {
    testsetplatform win
    file join a /b
} {/b}
test filecmd-8.69 {joinPath: win} {
    testsetplatform win
    file join a /b c
} {/b/c}
test filecmd-8.70 {joinPath: win} {
    testsetplatform win
    file join /a// ///b
} {/b}

test filecmd-8.71 {joinPath: win} {
    testsetplatform win
    file join c:
} {c:}
test filecmd-8.72 {joinPath: win} {
    testsetplatform win
    file join c: foo
} {c:foo}
test filecmd-8.73 {joinPath: win} {
    testsetplatform win
    file join c:/
} {c:/}
test filecmd-8.74 {joinPath: win} {
    testsetplatform win
    file join c:/ foo
} {c:/foo}
test filecmd-8.75 {joinPath: win} {
    testsetplatform win
    file join c:\\bar foo
} {c:/bar/foo}
test filecmd-8.76 {joinPath: win} {
    testsetplatform win
    file join /foo c:bar
} {c:bar}
test filecmd-8.77 {joinPath: win} {
    testsetplatform win
    file join foo c:bar de:baz
} {c:bar/de:baz}
test filecmd-8.78 {joinPath: win} {
    testsetplatform win
    file join foo c: bar de:
} {c:bar/de:}

test filecmd-8.79 {joinPath: win} {
    testsetplatform win
    file join ///host//share dir
} {//host/share/dir}
test filecmd-8.80 {joinPath: win} {
    testsetplatform win
    file join ///foo//z:
} {//foo/z:}
test filecmd-8.81 {joinPath: win} {
    testsetplatform win
    file join ///foo//z: bar
} {//foo/z:bar}
test filecmd-8.82 {joinPath: win} {
    testsetplatform win
    file join ///foo//z: :bar
} {//foo/z::bar}
test filecmd-8.83 {joinPath: win} {
    testsetplatform win
    file join /foo ///host//share
} {//host/share}
test filecmd-8.84 {joinPath: win} {
    testsetplatform win
    file join foo ///bar//baz ///host//share 
} {//host/share}

test filecmd-8.85 {joinPath: win} {
    testsetplatform win
    file join ~ foo
} {~/foo}
test filecmd-8.86 {joinPath: win} {
    testsetplatform win
    file join ~/~foo
} {~/~foo}
test filecmd-8.87 {joinPath: win} {
    testsetplatform win
    file join ~ ./~foo
} {~/~foo}
test filecmd-8.88 {joinPath: win} {
    testsetplatform win
    file join / ~foo
} {~foo}
test filecmd-8.89 {joinPath: win} {
    testsetplatform win
    file join ./~a/ b c
} {./~a/b/c}
test filecmd-8.90 {joinPath: win} {
    testsetplatform win
    file join a ~b c
} {~b/c}

# join mac platform: relative pathes

test filecmd-8.91 {joinPath: mac} {
    testsetplatform mac
    file join a b
} {:a:b}
test filecmd-8.92 {joinPath: mac} {
    testsetplatform mac
    file join a :: b
} {:a::b}
test filecmd-8.93 {joinPath: mac} {
    testsetplatform mac
    file join a :: :: b
} {:a:::b}
test filecmd-8.94 {joinPath: mac} {
    testsetplatform mac
    file join ::
} {::}
test filecmd-8.95 {joinPath: mac} {
    testsetplatform mac
    file join :: a
} {::a}
test filecmd-8.96 {joinPath: mac} {
    testsetplatform mac
    file join a ::
} {:a::}
test filecmd-8.97 {joinPath: mac} {
    testsetplatform mac
    file join :: :: ::
} {::::}
test filecmd-8.98 {joinPath: mac} {
    testsetplatform mac
    file join :a
} {:a}
test filecmd-8.99 {joinPath: mac} {
    testsetplatform mac
    file join :a:
} {:a}
test filecmd-8.100 {joinPath: mac} {
    testsetplatform mac
    file join :a::
} {:a::}
test filecmd-8.101 {joinPath: mac} {
    testsetplatform mac
    file join :a::::
} {:a::::}
test filecmd-8.102 {joinPath: mac} {
    testsetplatform mac
    file join :a b
} {:a:b}
test filecmd-8.103 {joinPath: mac} {
    testsetplatform mac
    file join :a: b
} {:a:b}
test filecmd-8.104 {joinPath: mac} {
    testsetplatform mac
    file join :a :b
} {:a:b}
test filecmd-8.105 {joinPath: mac} {
    testsetplatform mac
    file join :a: :b
} {:a:b}
test filecmd-8.106 {joinPath: mac} {
    testsetplatform mac
    file join :a: :b:
} {:a:b}
test filecmd-8.107 {joinPath: mac} {
    testsetplatform mac
    file join :a: :b::
} {:a:b::}
test filecmd-8.108 {joinPath: mac} {
    testsetplatform mac
    file join :a: :b::::
} {:a:b::::}
test filecmd-8.109 {joinPath: mac} {
    testsetplatform mac
    file join ::a
} {::a}
test filecmd-8.110 {joinPath: mac} {
    testsetplatform mac
    file join :::a
} {:::a}
test filecmd-8.111 {joinPath: mac} {
    testsetplatform mac
    file join b ::a
} {:b::a}
test filecmd-8.112 {joinPath: mac} {
    testsetplatform mac
    file join b :::a
} {:b:::a}
test filecmd-8.113 {joinPath: mac} {
    testsetplatform mac
    file join :~
} {:~}
test filecmd-8.114 {joinPath: mac} {
    testsetplatform mac
    file join :~abc
} {:~abc}
test filecmd-8.115 {joinPath: mac} {
    testsetplatform mac
    file join a :~bc d
} {:a:~bc:d}
test filecmd-8.116 {joinPath: mac} {
    testsetplatform mac
    file join a b/c d
} {:a:b:c:d}
test filecmd-8.117 {joinPath: mac} {
    testsetplatform mac
    file join /
} {:/}
test filecmd-8.118 {joinPath: mac} {
    testsetplatform mac
    file join /..
} {:/..}
test filecmd-8.119 {joinPath: mac} {
    testsetplatform mac
    file join //.//.././
} {://.//.././}
test filecmd-8.120 {joinPath: mac} {
    testsetplatform mac
    file join / abc /
} {:/:abc:/}
test filecmd-8.121 {joinPath: mac} {
    testsetplatform mac
    file join /// //
} {:///://}
test filecmd-8.122 {joinPath: mac} {
    testsetplatform mac
    file join a {} b
} {:a:b}
test filecmd-8.123 {joinPath: mac} {
    testsetplatform mac
    file join {} {} {}
} {}
test filecmd-8.124 {joinPath: mac} {
    testsetplatform mac
    file join :
} {:}
test filecmd-8.125 {joinPath: mac} {
    testsetplatform mac
    file join a :
} {:a}
test filecmd-8.126 {joinPath: mac} {
    testsetplatform mac
    file join a : : :
} {:a}
test filecmd-8.127 {joinPath: mac} {
    testsetplatform mac
    file join : : :
} {:}
test filecmd-8.128 {joinPath: mac} {
    testsetplatform mac
    file join : a
} {:a}
test filecmd-8.129 {joinPath: mac} {
    testsetplatform mac
    file join : : : a
} {:a}
test filecmd-8.130 {joinPath: mac} {
    testsetplatform mac
    file join a : b
} {:a:b}
test filecmd-8.131 {joinPath: mac} {
    testsetplatform mac
    file join a : : : b
} {:a:b}
test filecmd-8.132 {joinPath: mac} {
    testsetplatform mac
    file join a ::: b
} {:a:::b}
test filecmd-8.133 {joinPath: mac} {
    testsetplatform mac
    file join a :::: b
} {:a::::b}
test filecmd-8.134 {joinPath: mac} {
    testsetplatform mac
    file join :a :b/c
} {:a:b/c}

# join mac platform: absolute pathes

test filecmd-8.135 {joinPath: mac} {
    testsetplatform mac
    file join /a
} {a:}
test filecmd-8.136 {joinPath: mac} {
    testsetplatform mac
    file join /a///b
} {a:b}
test filecmd-8.137 {joinPath: mac} {
    testsetplatform mac
    file join ///.././/a b
} {a:b}
test filecmd-8.138 {joinPath: mac} {
    testsetplatform mac
    file join /a/b c/d
} {a:b:c:d}
test filecmd-8.139 {joinPath: mac} {
    testsetplatform mac
    file join /a/b /c
} {c:}
test filecmd-8.140 {joinPath: mac} {
    testsetplatform mac
    file join /a/b :c:d
} {a:b:c:d}
test filecmd-8.141 {joinPath: mac} {
    testsetplatform mac
    file join /a///../b
} {a::b}

test filecmd-8.142 {joinPath: mac} {
    testsetplatform mac
    file join a:
} {a:}
test filecmd-8.143 {joinPath: mac} {
    testsetplatform mac
    file join a b:
} {b:}
test filecmd-8.144 {joinPath: mac} {
    testsetplatform mac
    file join a: :b
} {a:b}
test filecmd-8.145 {joinPath: mac} {
    testsetplatform mac
    file join a: :b:
} {a:b}
test filecmd-8.146 {joinPath: mac} {
    testsetplatform mac
    file join a: :b::
} {a:b::}
test filecmd-8.147 {joinPath: mac} {
    testsetplatform mac
    file join a: b:
} {b:}
test filecmd-8.148 {joinPath: mac} {
    testsetplatform mac
    file join a:bc d/e
} {a:bc:d:e}
test filecmd-8.149 {joinPath: mac} {
    testsetplatform mac
    file join a::
} {a::}
test filecmd-8.150 {joinPath: mac} {
    testsetplatform mac
    file join a::::
} {a::::}
test filecmd-8.151 {joinPath: mac} {
    testsetplatform mac
    file join a: ::
} {a::}
test filecmd-8.152 {joinPath: mac} {
    testsetplatform mac
    file join a::: b
} {a:::b}
test filecmd-8.153 {joinPath: mac} {
    testsetplatform mac
    file join a: :b/c
} {a:b/c}
test filecmd-8.154 {joinPath: mac} {
    testsetplatform mac
    file join a: b/c
} {a:b:c}

test filecmd-8.155 {joinPath: mac} {
    testsetplatform mac
    file join ~ foo
} {~:foo}

# error handling of Tcl_TranslateFileName

test filecmd-9.1 {cmdProc} {
    testsetplatform unix
    list [catch {file readable ~_bad_user} msg] $msg
} {1 {user "_bad_user" doesn't exist}}

# Temporary early return
#testsetplatform $platform
#puts "Skipping fileCmd tests that use fconfigure."
#puts "The fconfigure command is not yet implemented in Jacl."
#return

testsetplatform $platform
makeFile abcde gorp.file
makeDirectory dir.file

# readable
# Can't run on macintosh - requires chmod
if {$tcl_platform(platform) != "macintosh"} {

test filecmd-10.1 {cmdProc: readable} {
    list [catch {file readable a b} msg] $msg
} {1 {wrong # args: should be "file readable name"}}
catch {exec chmod 444 gorp.file}
test filecmd-10.2 {cmdProc: readable} {unixExecs} {file readable gorp.file} 1
catch {exec chmod 333 gorp.file}
if {$env(USER) != "root"} {
    test filecmd-10.3 {cmdProc: readable} {unixOnly} {
	file reada gorp.file
    } 0
}
}

# writable
# Can't run on macintosh - requires chmod
if {$tcl_platform(platform) != "macintosh"} {

test filecmd-11.1 {cmdProc: writable} {
    list [catch {file writable a b} msg] $msg
} {1 {wrong # args: should be "file writable name"}}
catch {exec chmod 555 gorp.file}
if {$env(USER) != "root"} {
    test filecmd-11.2 {cmdProc: writable} {unixExecs} {
	file writable gorp.file
    } 0
}
catch {exec chmod 222 gorp.file}
test filecmd-11.3 {cmdProc: writable} {unixExecs} {file w gorp.file} 1
}

# executable
# Can't run on macintosh - requires chmod
if {$tcl_platform(platform) != "macintosh"} {

test filecmd-12.1 {cmdProc: executable} {unixExecs} {
    list [catch {file executable a b} msg] $msg
} {1 {wrong # args: should be "file executable name"}}
catch {exec chmod 000 dir.file}
if {$env(USER) != "root"} {
    test filecmd-12.2 {cmdProc: executable} {unixOnly} {
	file executable gorp.file
    } 0
}
catch {exec chmod 775 gorp.file}
test filecmd-12.3 {cmdProc: executable} {unixExecs} {file exe gorp.file} 1
}

# exists

test filecmd-13.1 {cmdProc: exists} {
    list [catch {file exists a b} msg] $msg
} {1 {wrong # args: should be "file exists name"}}
catch {exec chmod 777 dir.file}
file delete -force dir.file  
file delete gorp.file
file delete link.file
test filecmd-13.2 {cmdProc: exists} {file exists gorp.file} 0
test filecmd-13.3 {cmdProc: exists} {
    file exists [file join dir.file gorp.file]
} 0
catch {
    makeFile abcde gorp.file
    makeDirectory dir.file
    makeFile 12345 [file join dir.file gorp.file]
}
test filecmd-13.4 {cmdProc: exists} {unixExecs} {file exists gorp.file} 1
test filecmd-13.5 {cmdProc: exists} {unixExecs} {
    file exists [file join dir.file gorp.file]
} 1
test filecmd-13.5 {cmdProc: exists} {
    file exists ~/_bogus_
} 0


# The test below has to be done in /tmp rather than the current
# directory in order to guarantee (?) a local file system:  some
# NFS file systems won't do the stuff below correctly.

if {$tcl_platform(platform) == "unix"} {
    file delete /tmp/tcl.foo.dir/file
    removeDirectory /tmp/tcl.foo.dir
    makeDirectory /tmp/tcl.foo.dir
    makeFile 12345 /tmp/tcl.foo.dir/file
    exec chmod 000 /tmp/tcl.foo.dir
    if {$env(USER) != "root"} {
	test filecmd-13.6 {cmdProc: exists} {
	    file exists /tmp/tcl.foo.dir/file
	} 0
    }
    exec chmod 775 /tmp/tcl.foo.dir
    file delete /tmp/tcl.foo.dir/file
    removeDirectory /tmp/tcl.foo.dir
}

# Stat related commands

testsetplatform $platform
file delete gorp.file
makeFile "Test string" gorp.file
catch {exec chmod 765 gorp.file}

# atime

test filecmd-14.1 {cmdProc: atime} {
    list [catch {file atime a b} msg] $msg
} {1 {wrong # args: should be "file atime name"}}
test filecmd-14.2 {cmdProc: atime} {
    catch {unset stat}
    file stat gorp.file stat
    list [expr {[file mtime gorp.file] == $stat(mtime)}] \
	    [expr {[file atime gorp.file] == $stat(atime)}]
} {1 1}
test filecmd-14.2 {cmdProc: atime} {
    string tolower [list [catch {file atime _bogus_} msg] \
	    $msg $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}

# isdirectory

test filecmd-15.1 {cmdProc: isdirectory} {
    list [catch {file isdirectory a b} msg] $msg
} {1 {wrong # args: should be "file isdirectory name"}}
test filecmd-15.2 {cmdProc: isdirectory} {file isdirectory gorp.file} 0
test filecmd-15.3 {cmdProc: isdirectory} {unixExecs} {file isd dir.file} 1

# isfile

test filecmd-15.4 {cmdProc: isfile} {
    list [catch {file isfile a b} msg] $msg
} {1 {wrong # args: should be "file isfile name"}}
test filecmd-15.5 {cmdProc: isfile} {file isfile gorp.file} 1
test filecmd-15.6 {cmdProc: isfile} {file isfile dir.file} 0

# lstat and readlink:  don't run these tests everywhere, since not all
# sites will have symbolic links

proc skip {} {
catch {exec ln -s gorp.file link.file}
test filecmd-16.1 {cmdProc: lstat} {unixExecs} {
    list [catch {file lstat a} msg] $msg
} {1 {wrong # args: should be "file lstat name varName"}}
test filecmd-16.2 {cmdProc: lstat} {unixExecs} {
    list [catch {file lstat a b c} msg] $msg
} {1 {wrong # args: should be "file lstat name varName"}}
test filecmd-16.3 {cmdProc: lstat} {unixOnly nonPortable} {
    catch {unset stat}
    file lstat link.file stat
    lsort [array names stat]
} {atime ctime dev gid ino mode mtime nlink size type uid}
test filecmd-16.4 {cmdProc: lstat} {unixOnly nonPortable} {
    catch {unset stat}
    file lstat link.file stat
    list $stat(nlink) [expr $stat(mode)&0777] $stat(type)
} {1 511 link}
test filecmd-16.5 {cmdProc: lstat errors} {nonPortable} {
    string tolower [list [catch {file lstat _bogus_ stat} msg] \
	    $msg $errorCode]
} {1 {couldn't lstat "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test filecmd-16.6 {cmdProc: lstat errors} {unixExecs nonPortable} {
    catch {unset x}
    set x 44
    list [catch {file lstat gorp.file x} msg] $msg $errorCode
} {1 {can't set "x(dev)": variable isn't array} NONE}
catch {unset stat}
}
# mtime 

test filecmd-17.1 {cmdProc: mtime} {
    list [catch {file mtime a b} msg] $msg
} {1 {wrong # args: should be "file mtime name"}}
test filecmd-17.2 {cmdProc: mtime} {unixExecs} {
    set old [file mtime gorp.file]
    after 2000
    set f [open gorp.file w]
    puts $f "More text"
    close $f
    set new [file mtime gorp.file]
    #expr {($new > $old) && ($new <= ($old+5))}
    expr {($new > $old)}
} {1}
test filecmd-17.3 {cmdProc: mtime} {unixExecs} {
    catch {unset stat}
    file stat gorp.file stat
    list [expr {[file mtime gorp.file] == $stat(mtime)}] \
	    [expr {[file atime gorp.file] == $stat(atime)}]
} {1 1}
test filecmd-17.4 {cmdProc: mtime} {unixExecs} {
    string tolower [list [catch {file mtime _bogus_} msg] $msg \
	    $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}

# owned

test filecmd-18.1 {cmdProc: owned} {
    list [catch {file owned a b} msg] $msg
} {1 {wrong # args: should be "file owned name"}}
test filecmd-18.2 {cmdProc: owned} {unixExecs} {file owned gorp.file} 1
if {$env(USER) != "root"} {
    test filecmd-18.3 {cmdProc: owned} {unixOnly} {file owned /} 0
}
test filecmd-18.4 {cmdProc: owned} {unixOnly} {file owned _bogus_} 0
test filecmd-18.5 {cmdProc: owned} {unixOnly} {
    if {[file exist gorp.file]} {
	set x [file owned gorp.file]
    } else {
	exec echo "hello world" > gorp.file
	set x [list [catch {file owned gorp.file} msg] $msg]
	file del gorp.file
    }
    set x
} {1 {file owned command is not yet implemented on Unix.}}

# readlink

test filecmd-19.1 {cmdProc: readlink} {
    list [catch {file readlink a b} msg] $msg
} {1 {wrong # args: should be "file readlink name"}}
test filecmd-19.2 {cmdProc: readlink} {unixOnly nonPortable} {
    file readlink link.file
} gorp.file
test filecmd-19.3 {cmdProc: readlink errors} {unixOnly nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] \
	    [string tolower $errorCode]
} {1 {couldn't readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test filecmd-19.4 {cmdProc: readlink errors} {macOnly nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] \
	    [string tolower $errorCode]
} {1 {couldn't readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test filecmd-19.5 {cmdProc: readlink errors} {pcOnly nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] \
	    [string tolower $errorCode]
} {1 {couldn't readlink "_bogus_": invalid argument} {posix einval {invalid argument}}}

# size

test filecmd-20.1 {cmdProc: size} {
    list [catch {file size a b} msg] $msg
} {1 {wrong # args: should be "file size name"}}
test filecmd-20.2 {cmdProc: size} {
    set oldsize [file size gorp.file]
    set f [open gorp.file a]
    fconfigure $f -translation lf -eofchar {}
    puts $f "More text"
    close $f
    expr {[file size gorp.file] - $oldsize}
} {10}
test filecmd-20.3 {cmdProc: size} {
    string tolower [list [catch {file size _bogus_} msg] $msg \
	    $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}

# stat

testsetplatform $platform
makeFile "Test string" gorp.file
catch {exec chmod 765 gorp.file}

test filecmd-21.1 {cmdProc: stat} {
    list [catch {file stat _bogus_} msg] $msg $errorCode
} {1 {wrong # args: should be "file stat name varName"} NONE}
test filecmd-21.2 {cmdProc: stat} {
    list [catch {file stat _bogus_ a b} msg] $msg $errorCode
} {1 {wrong # args: should be "file stat name varName"} NONE}
test filecmd-21.3 {cmdProc: stat} {
    catch {unset stat}
    file stat gorp.file stat
    lsort [array names stat]
} {atime ctime dev gid ino mode mtime nlink size type uid}
test filecmd-21.4 {cmdProc: stat} {unixOnly} {
    catch {unset stat}
    file stat gorp.file stat
    list $stat(nlink) $stat(size) [expr $stat(mode)&0777] $stat(type)
} {1 12 501 file}
test filecmd-21.5 {cmdProc: stat} {
    string tolower [list [catch {file stat _bogus_ stat} msg] \
	    $msg $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test filecmd-21.6 {cmdProc: stat} {
    catch {unset x}
    set x 44
    list [catch {file stat gorp.file x} msg] $msg $errorCode
} {1 {can't set "x(dev)": variable isn't array} NONE}
catch {unset stat}

# type

file delete link.file

test filecmd-22.1 {cmdProc: type} {
    list [catch {file size a b} msg] $msg
} {1 {wrong # args: should be "file size name"}}
test filecmd-22.2 {cmdProc: type} {unixExecs} {
    file type dir.file
} directory
test filecmd-22.3 {cmdProc: type} {
    file type gorp.file
} file
test filecmd-22.4 {cmdProc: type} {unixOnly nonPortable} {
    exec ln -s a/b/c link.file
    set result [file type link.file]
    file delete link.file
    set result
} link
test filecmd-22.5 {cmdProc: type} {
    string tolower [list [catch {file type _bogus_} msg] $msg $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}

# Error conditions

test filecmd-23.1 {error conditions} {
    list [catch {file gorp x} msg] $msg
} [list 1 "bad option \"gorp\": must be $file_options"]
test filecmd-23.2 {error conditions} {
    list [catch {file ex x} msg] $msg
} [list 1 "ambiguous option \"ex\": must be $file_options"]
test filecmd-23.3 {error conditions} {
    list [catch {file is x} msg] $msg
} [list 1 "ambiguous option \"is\": must be $file_options"]
test filecmd-23.4 {error conditions} {
    list [catch {file n x} msg] $msg
} [list 1 "ambiguous option \"n\": must be $file_options"]
test filecmd-23.5 {error conditions} {
    list [catch {file read x} msg] $msg
} [list 1 "ambiguous option \"read\": must be $file_options"]
test filecmd-23.6 {error conditions} {
    list [catch {file s x} msg] $msg
} [list 1 "ambiguous option \"s\": must be $file_options"]
test filecmd-23.7 {error conditions} {
    list [catch {file t x} msg] $msg
} [list 1 "ambiguous option \"t\": must be $file_options"]
test filecmd-23.8 {error conditions} {
    list [catch {file dirname ~woohgy} msg] $msg
} {1 {user "woohgy" doesn't exist}}

testsetplatform $platform
catch {unset platform}

catch {exec chmod 777 dir.file}
catch {unset msg}
catch {file delete -force dir.file} msg(1)
catch {file delete gorp.file} msg(2)
catch {file delete link.file} msg(3)
foreach i "1 2 3" {
    if {[string length $msg($i)] > 0} {
	puts $msg($i)
    } else {
	puts "no catch"
    }
}
catch {unset msg}

##################
#
#   Tests for fCmd
#
##################

proc createfile {file {string a}} {
    set f [open $file w]
    puts -nonewline $f $string
    close $f
    return $string
}

# 
# checkcontent --
#
#  Ensures that file "file" contains only the string "matchString"
#  returns 0 if the file does not exist, or has a different content
#
proc checkcontent {file matchString} {
    if {[catch {
	set f [open $file]
	set fileString [read $f]
	close $f 
    }]} {
	return 0
    }
    return [string match $matchString $fileString]
}

proc cleanup {args} {
    foreach p ". $args" {
	set x ""
	catch {
	    set x [glob [file join $p tf*] [file join $p td*]]
	}
	if {$x != ""} {
	    eval file delete -force $x
	}
    }
}

proc contents {file} {
    set f [open $file r]
    set r [read $f]
    close $f
    set r
}

set testConfig(NT) 0
set testConfig(95) 0

switch $tcl_platform(os) {
    "Windows NT" {set testConfig(NT) 1}
    "Windows 95" {set testConfig(95) 1}
}

set root [lindex [file split [pwd]] 0]

# A really long file name
# length of long is 1216 chars, which should be greater than any static
# buffer or allowable filename.

set long "abcdefghihjllmnopqrstuvwxyz01234567890"
append long $long
append long $long
append long $long
append long $long
append long $long

test filecmd-31.1 {TclFileRenameCmd} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}

test filecmd-32.1 {TclFileCopyCmd} {
    cleanup
    createfile tf1
    file copy tf1 tf2
    lsort [glob tf*]
} {tf1 tf2}

test filecmd-33.1 {FileCopyRename: FileForceOption fails} {
    list [catch {file rename -xyz} msg] $msg
} {1 {bad option "-xyz": must be -force or --}}
test filecmd-33.2 {FileCopyRename: not enough args} {
    list [catch {file rename xyz} msg] $msg
} {1 {wrong # args: should be "file rename ?options? source ?source ...? target"}}
test filecmd-33.2 {TclFileCopyRename: empty source file name} {
    list [catch {file copy "" junk} msg] $msg
} {1 {error copying "": no such file or directory}}
test filecmd-33.2 {TclFileCopyRename: empty source file name} {
    list [catch {file copy -force "" junk} msg] $msg
} {1 {error copying "": no such file or directory}}
test filecmd-33.2 {TclFileCopyRename: empty target file name} {
    cleanup
    createfile tf1
    list [catch {file copy tf1 ""} msg] $msg
} {1 {error copying "tf1" to "": no such file or directory}}
test filecmd-33.2 {TclFileCopyRename: empty target file name} {
    cleanup
    createfile tf1
    list [catch {file copy -force tf1 ""} msg] $msg
} {1 {error copying "tf1" to "": no such file or directory}}
test filecmd-33.3 {FileCopyRename: Tcl_TranslateFileName fails} {
    list [catch {file rename xyz ~nonexistantuser} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test filecmd-33.4 {FileCopyRename: Tcl_TranslateFileName passes} {
    cleanup
    list [catch {file copy tf1 ~} msg] $msg
} {1 {error copying "tf1": no such file or directory}}
test filecmd-33.5 {FileCopyRename: target doesn't exist: stat(target) != 0} {
    cleanup
    list [catch {file rename tf1 tf2 tf3} msg] $msg
} {1 {error renaming: target "tf3" is not a directory}}
test filecmd-33.6 {FileCopyRename: target tf3 is not a directory: !S_ISDIR(target)} {
    cleanup
    createfile tf3
    list [catch {file rename tf1 tf2 tf3} msg] $msg
} {1 {error renaming: target "tf3" is not a directory}}
test filecmd-33.7 {FileCopyRename: target exists & is directory} {
    cleanup
    file mkdir td1
    createfile tf1 tf1
    file rename tf1 td1
    contents [file join td1 tf1]
} {tf1}
test filecmd-33.8 {FileCopyRename: too many arguments: argc - i > 2} {
    cleanup
    list [catch {file rename tf1 tf2 tf3} msg] $msg
} {1 {error renaming: target "tf3" is not a directory}}
test filecmd-33.9 {FileCopyRename: too many arguments: argc - i > 2} {
    cleanup
    list [catch {file copy -force -- tf1 tf2 tf3} msg] $msg
} {1 {error copying: target "tf3" is not a directory}}
test filecmd-33.10 {FileCopyRename: just 2 arguments} {
    cleanup
    createfile tf1 tf1
    file rename tf1 tf2
    contents tf2
} {tf1}
test filecmd-33.11 {FileCopyRename: just 2 arguments} {
    cleanup
    createfile tf1 tf1
    file rename -force -force -- tf1 tf2
    contents tf2
} {tf1}
test filecmd-33.12 {FileCopyRename: move each source: 1 source} {
    cleanup
    createfile tf1 tf1
    file mkdir td1
    file rename tf1 td1
    contents [file join td1 tf1]
} {tf1}
test filecmd-33.13 {FileCopyRename: move each source: multiple sources} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    createfile tf3 tf3
    createfile tf4 tf4
    file mkdir td1
    file rename tf1 tf2 tf3 tf4 td1
    list [contents [file join td1 tf1]] [contents [file join td1 tf2]] \
	[contents [file join td1 tf3]] [contents [file join td1 tf4]]
} {tf1 tf2 tf3 tf4}
test filecmd-33.14 {FileCopyRename: FileBasename fails} {
    cleanup
    file mkdir td1
    list [catch {file rename ~nonexistantuser td1} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test filecmd-33.15 {FileCopyRename: source[0] == '\0'} {unixOrPc} {
    cleanup
    file mkdir td1
    list [catch {file rename / td1} msg] $msg
} {1 {error renaming "/" to "td1": file already exists}}
test filecmd-33.16 {FileCopyRename: break on first error} {
    cleanup
    createfile tf1 
    createfile tf2 
    createfile tf3 
    createfile tf4 
    file mkdir td1
    createfile [file join td1 tf3]
    list [catch {file rename tf1 tf2 tf3 tf4 td1} msg] $msg
} [subst {1 {error renaming "tf3" to "[file join td1 tf3]": file already exists}}]
test filecmd-34.1 {TclFileMakeDirsCmd: make each dir: 1 dir} {
    cleanup
    file mkdir td1
    glob td*
} {td1}
test filecmd-34.2 {TclFileMakeDirsCmd: make empty dir} {
    list [catch {file mkdir ""}  msg] $msg
} {1 {can't create directory "": no such file or directory}}
test filecmd-34.2 {TclFileMakeDirsCmd: make each dir: multiple dirs} {
    cleanup
    file mkdir td1 td2 td3
    lsort [glob td*]
} {td1 td2 td3}
test filecmd-34.3 {TclFileMakeDirsCmd: stops on first error} {
    cleanup
    createfile tf1
    catch {file mkdir td1 td2 tf1 td3 td4}
    glob td1 td2 tf1 td3 td4
} {td1 td2 tf1}
test filecmd-34.4 {TclFileMakeDirsCmd: Tcl_TranslateFileName fails} {
    cleanup
    list [catch {file mkdir ~nonexistantuser} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test filecmd-34.5 {TclFileMakeDirsCmd: Tcl_SplitPath returns 0: *name == '\0'} {
    cleanup
    list [catch {file mkdir ""} msg] $msg
} {1 {can't create directory "": no such file or directory}}
test filecmd-34.6 {TclFileMakeDirsCmd: one level deep} {
    cleanup
    file mkdir td1
    glob td1
} {td1}
test filecmd-34.7 {TclFileMakeDirsCmd: multi levels deep} {
    cleanup
    file mkdir [file join td1 td2 td3 td4]
    glob td1 [file join td1 td2]
} "td1 [file join td1 td2]"
test filecmd-34.8 {TclFileMakeDirsCmd: already exist: lstat(target) == 0} {
    cleanup
    file mkdir td1
    set x [file exist td1]
    file mkdir td1
    list $x [file exist td1]
} {1 1}
test filecmd-34.9 {TclFileMakeDirsCmd: exists, not dir} {
    cleanup
    createfile tf1
    list [catch {file mkdir tf1} msg] $msg
} [subst {1 {can't create directory "[file join tf1]": file already exists}}]
test filecmd-34.10 {TclFileMakeDirsCmd: exists, is dir} {
    cleanup
    file mkdir td1
    set x [file exist td1]
    file mkdir td1
    list $x [file exist td1]
} {1 1}
test filecmd-34.11 {TclFileMakeDirsCmd: doesn't exist: errno != ENOENT} {unixOnly} {
    cleanup
    file mkdir td1/td2/td3
    testchmod 000 td1/td2
    set msg [list [catch {file mkdir td1/td2/td3/td4} msg] $msg]
    testchmod 755 td1/td2
    set msg
} {1 {can't create directory "td1/td2/td3": permission denied}}
test filecmd-34.12 {TclFileMakeDirsCmd: doesn't exist: errno != ENOENT} {macOnly} {
    cleanup
    list [catch {file mkdir nonexistantvolume:} msg] $msg
} {1 {can't create directory "nonexistantvolume:": invalid argument}}
test filecmd-34.13 {TclFileMakeDirsCmd: doesn't exist: errno == ENOENT} {
    cleanup
    set x [file exist td1]
    file mkdir td1
    list $x [file exist td1]
} {0 1}
test filecmd-34.14 {TclFileMakeDirsCmd: TclpCreateDirectory fails} {unixOnly nonPortable} {
    cleanup
    list [catch {file mkdir /tf1} msg] $msg
} {1 {can't create directory "/tf1": permission denied}}
test filecmd-34.15 {TclFileMakeDirsCmd: TclpCreateDirectory fails} {pcOnly} {
    # error message is either "permission denied" or "file already exists"
    catch {file mkdir c:.} msg
    string range $msg 0 26
} {can't create directory "c:"}
test filecmd-34.16 {TclFileMakeDirsCmd: TclpCreateDirectory fails} {macOnly} {
    list [catch {file mkdir ${root}:} msg] $msg
} [subst {1 {can't create directory "${root}:": no such file or directory}}]
test filecmd-34.17 {TclFileMakeDirsCmd: TclpCreateDirectory succeeds} {
    cleanup
    file mkdir tf1
    file exists tf1
} {1}

test filecmd-35.1 {TclFileDeleteCmd: FileForceOption fails} {
    list [catch {file delete -xyz} msg] $msg
} {1 {bad option "-xyz": must be -force or --}}
test filecmd-35.2 {TclFileDeleteCmd: not enough args} {
    list [catch {file delete -force -force} msg] $msg
} {1 {wrong # args: should be "file delete ?options? file ?file ...?"}}
test filecmd-35.2 {TclFileDeleteCmd: empty file name} {
    list [catch {file delete ""} msg] $msg
} {0 {}}
test filecmd-35.3 {TclFileDeleteCmd: 1 file} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    file delete tf2
    glob tf* td*
} {tf1 td1}
test filecmd-35.4 {TclFileDeleteCmd: multiple files} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    set x [list [file exist tf1] [file exist tf2] [file exist td1]]
    file delete tf1 td1 tf2
    lappend x [file exist tf1] [file exist tf2] [file exist tf3]
} {1 1 1 0 0 0}
test filecmd-35.5 {TclFileDeleteCmd: stop at first error} {unixOrPc} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    catch {file delete tf1 td1 $root tf2}
    list [file exist tf1] [file exist tf2] [file exist td1]
} {0 1 0}
test filecmd-35.6 {TclFileDeleteCmd: Tcl_TranslateFileName fails} {
    list [catch {file delete ~nonexistantuser} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test filecmd-35.7 {TclFileDeleteCmd: Tcl_TranslateFileName succeeds} {
    file delete ~/tf1
    createfile ~/tf1
    file delete ~/tf1
} {}
test filecmd-35.8 {TclFileDeleteCmd: file doesn't exist: lstat(name) != 0} {
    cleanup
    set x [file exist tf1]
    file delete tf1
    list $x [file exist tf1]
} {0 0}    
test filecmd-35.9 {TclFileDeleteCmd: is directory} {
    cleanup
    file mkdir td1
    file delete td1
    file exist td1
} {0}
test filecmd-35.10 {TclFileDeleteCmd: TclpRemoveDirectory fails} {
    cleanup
    file mkdir td1/td2
    list [catch {file delete td1} msg] $msg
} {1 {error deleting "td1": directory not empty}}

test filecmd-36.1 {CopyRenameOneFile: bad source} {
    # can't test this, because it's caught by FileCopyRename
} {}
test filecmd-36.2 {CopyRenameOneFile: bad target} {
    # can't test this, because it's caught by FileCopyRename
} {}
test filecmd-36.3 {CopyRenameOneFile: lstat(source) != 0} {
    cleanup
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1": no such file or directory}}
test filecmd-36.4 {CopyRenameOneFile: lstat(source) == 0} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}
test filecmd-36.5 {CopyRenameOneFile: lstat(target) != 0} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}
test filecmd-36.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly} {
    cleanup
    file mkdir td1
    testchmod 000 td1
    createfile tf1
    set msg [list [catch {file rename tf1 td1} msg] $msg]
    testchmod 755 td1
    set msg
} {1 {error renaming "tf1" to "td1/tf1": permission denied}}
test filecmd-36.7 {CopyRenameOneFile: errno != ENOENT} {95} {
    cleanup
    createfile tf1
    list [catch {file rename tf1 $long} msg] $msg
} [subst {1 {error renaming "tf1" to "$long": file name too long}}]
test filecmd-36.8 {CopyRenameOneFile: errno != ENOENT} {macOnly} {
    cleanup
    createfile tf1
    list [catch {file rename tf1 $long} msg] $msg
} [subst {1 {error renaming "tf1" to "$long": file name too long}}]
test filecmd-36.9 {CopyRenameOneFile: errno == ENOENT} {unixOnly} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}
test filecmd-36.10 {CopyRenameOneFile: lstat(target) == 0} {
    cleanup
    createfile tf1
    createfile tf2
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1" to "tf2": file already exists}}
test filecmd-36.11 {CopyRenameOneFile: force == 0} {
    cleanup
    createfile tf1
    createfile tf2
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1" to "tf2": file already exists}}
test filecmd-36.12 {CopyRenameOneFile: force != 0} {
    cleanup
    createfile tf1
    createfile tf2
    file rename -force tf1 tf2
    glob tf*
} {tf2}
test filecmd-36.13 {CopyRenameOneFile: source is dir, target is file} {
    cleanup
    file mkdir td1
    file mkdir td2
    createfile [file join td2 td1]
    list [catch {file rename -force td1 td2} msg] $msg
} [subst {1 {can't overwrite file "[file join td2 td1]" with directory "td1"}}]
test filecmd-36.14 {CopyRenameOneFile: source is file, target is dir} {
    cleanup
    createfile tf1
    file mkdir [file join td1 tf1]
    list [catch {file rename -force tf1 td1} msg] $msg
} [subst {1 {can't overwrite directory "[file join td1 tf1]" with file "tf1"}}]
test filecmd-36.15 {CopyRenameOneFile: TclpRenameFile succeeds} {
    cleanup
    file mkdir [file join td1 td2]
    file mkdir td2
    createfile [file join td2 tf1]
    file rename -force td2 td1
    file exists [file join td1 td2 tf1]
} {1}
test filecmd-36.16 {CopyRenameOneFile: TclpCopyRenameOneFile fails} {
    cleanup
    file mkdir [file join td1 td2]
    createfile [file join td1 td2 tf1]
    file mkdir td2
    list [catch {file rename -force td2 td1} msg] $msg
} [subst {1 {error renaming "td2" to "[file join td1 td2]": file already exists}}]
test filecmd-36.17 {CopyRenameOneFile: errno == EINVAL} {
    cleanup
    list [catch {file rename -force $root tf1} msg] $msg
} [subst {1 {error renaming "$root" to "tf1": trying to rename a volume or move a directory into itself}}]
test filecmd-36.18 {CopyRenameOneFile: errno != EXDEV} {
    cleanup
    file mkdir [file join td1 td2]
    createfile [file join td1 td2 tf1]
    file mkdir td2
    list [catch {file rename -force td2 td1} msg] $msg
} [subst {1 {error renaming "td2" to "[file join td1 td2]": file already exists}}]
test filecmd-36.19 {CopyRenameOneFile: errno == EXDEV} {unixOnly} {
    cleanup /tmp
    createfile tf1
    file rename tf1 /tmp
    glob tf* /tmp/tf1
} {/tmp/tf1}
test filecmd-36.20 {CopyRenameOneFile: errno == EXDEV} {pcOnly} {
    file delete -force c:/tcl8975@ d:/tcl8975@
    file mkdir c:/tcl8975@
    if [catch {file rename c:/tcl8975@ d:/}] {
	list d:/tcl8975@
    } else {
	set msg [glob c:/tcl8975@ d:/tcl8975@]
	file delete -force d:/tcl8975@
	set msg
    }
} {d:/tcl8975@}
test filecmd-36.21 {CopyRenameOneFile: copy/rename: S_ISDIR(source)} {unixOnly} {
    cleanup /tmp
    file mkdir td1
    file rename td1 /tmp
    glob td* /tmp/td*
} {/tmp/td1}
test filecmd-36.22 {CopyRenameOneFile: copy/rename: !S_ISDIR(source)} {unixOnly} {
    cleanup /tmp
    createfile tf1
    file rename tf1 /tmp
    glob tf* /tmp/tf*
} {/tmp/tf1}
test filecmd-36.23 {CopyRenameOneFile: TclpCopyDirectory failed} {unixOnly} {
    cleanup /tmp
    file mkdir td1/td2/td3
    exec chmod 000 td1
    set msg [list [catch {file rename td1 /tmp} msg] $msg]
    exec chmod 755 td1
    set msg
} {1 {error renaming "td1": permission denied}}
test filecmd-36.24 {CopyRenameOneFile: error uses original name} {unixOnly} {
    cleanup
    file mkdir ~/td1/td2
    exec chmod 000 [file join [file dirname ~] [file tail ~] td1]
    set msg [list [catch {file copy ~/td1 td1} msg] $msg]
    exec chmod 755 [file join [file dirname ~] [file tail ~] td1]
    file delete -force ~/td1
    set msg
} {1 {error copying "~/td1": permission denied}}
test filecmd-36.25 {CopyRenameOneFile: error uses original name} {unixOnly} {
    cleanup
    file mkdir td2
    file mkdir ~/td1
    exec chmod 000 [file join [file dirname ~] [file tail ~] td1]
    set msg [list [catch {file copy td2 ~/td1} msg] $msg]
    exec chmod 755 [file join [file dirname ~] [file tail ~] td1]
    file delete -force ~/td1
    set msg
} {1 {error copying "td2" to "~/td1/td2": permission denied}}
test filecmd-36.26 {CopyRenameOneFile: doesn't use original name} {unixOnly} {
    cleanup
    file mkdir ~/td1/td2
    exec chmod 000 [file join [file dirname ~] [file tail ~] td1 td2]
    set msg [list [catch {file copy ~/td1 td1} msg] $msg]
    exec chmod 755 [file join [file dirname ~] [file tail ~] td1 td2]
    file delete -force ~/td1
    set msg
} "1 {error copying \"~/td1\" to \"td1\": \"[file join [file dirname ~] [file tail ~] td1 td2]\": permission denied}"
test filecmd-36.27 {CopyRenameOneFile: TclpCopyDirectory failed} {unixOnly} {
    cleanup /tmp
    file mkdir td1/td2/td3
    file mkdir /tmp/td1
    createfile /tmp/td1/tf1
    list [catch {file rename -force td1 /tmp} msg] $msg
} {1 {error renaming "td1" to "/tmp/td1": file already exists}}
test filecmd-36.28 {CopyRenameOneFile: TclpCopyDirectory failed} {unixOnly} {
    cleanup /tmp
    file mkdir td1/td2/td3
    exec chmod 000 td1/td2/td3 
    set msg [list [catch {file rename td1 /tmp} msg] $msg]
    exec chmod 755 td1/td2/td3 
    set msg
} {1 {error renaming "td1" to "/tmp/td1": "td1/td2/td3": permission denied}}
test filecmd-36.29 {CopyRenameOneFile: TclpCopyDirectory passed} {unixOnly} {
    cleanup /tmp
    file mkdir td1/td2/td3
    file rename td1 /tmp
    glob td* /tmp/td1/t*
} {/tmp/td1/td2}
test filecmd-36.30 {CopyRenameOneFile: TclpRemoveDirectory failed} {unixOnly nonPortable} {
    cleanup
    if [file exists /kernel] {
        set msg [list [catch {file rename /kernel td1} msg] $msg]
	set a1 {1 {can't unlink "/kernel": permission denied}}
	expr {$msg == $a1}
    } else {
        list 1
    }
} {1}
test filecmd-36.31 {CopyRenameOneFile: TclpDeleteFile passed} {unixOnly} {
    cleanup /tmp
    file mkdir /tmp/td1
    createfile /tmp/td1/tf1
    file rename /tmp/td1/tf1 tf1
    list [file exists /tmp/td1/tf1] [file exists tf1]
} {0 1}
test filecmd-36.32 {CopyRenameOneFile: copy} {
    cleanup
    list [catch {file copy tf1 tf2} msg] $msg
} {1 {error copying "tf1": no such file or directory}}
cleanup /tmp

test filecmd-37.1 {FileForceOption: none} {
    cleanup
    file mkdir [file join tf1 tf2]
    list [catch {file delete tf1} msg] $msg
} {1 {error deleting "tf1": directory not empty}}
test filecmd-37.2 {FileForceOption: -force} {
    cleanup
    file mkdir [file join tf1 tf2]
    file delete -force tf1
} {}
test filecmd-37.3 {FileForceOption: --} {
    createfile -tf1
    file delete -- -tf1
} {}
test filecmd-37.4 {FileForceOption: bad option} {
    createfile -tf1
    set msg [list [catch {file delete -tf1} msg] $msg]
    file delete -- -tf1
    set msg
} {1 {bad option "-tf1": must be -force or --}}
test filecmd-37.5 {FileForceOption: multiple times through loop} {
    createfile --
    createfile -force
    file delete -force -force -- -- -force
    list [catch {glob -- -- -force} msg] $msg
} {1 {no files matched glob patterns "-- -force"}}

test filecmd-39.1 {file rename: comprehensive: EACCES} {unixOnly} {
    cleanup
    file mkdir td1
    list [catch {file rename td1 /} msg] $msg
} {1 {error renaming "td1" to "/td1": permission denied}}
test filecmd-39.2 {file rename: comprehensive: source doesn't exist} {
    cleanup
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1": no such file or directory}}
test filecmd-39.3 {file rename: comprehensive: file to new name} {
    cleanup
    createfile tf1
    createfile tf2
    testchmod 444 tf2
    file rename tf1 tf3
    file rename tf2 tf4
    list [lsort [glob tf*]] [file writable tf3] [file writable tf4]
} {{tf3 tf4} 1 0}    
test filecmd-39.4 {file rename: comprehensive: dir to new name} {unixOrPc} {
    cleanup
    file mkdir td1 td2
    testchmod 555 td2
    file rename td1 td3
    file rename td2 td4
    list [lsort [glob td*]] [file writable td3] [file writable td4]
} {{td3 td4} 1 0}    
test filecmd-39.5 {file rename: comprehensive: file to self} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    testchmod 444 tf2
    file rename -force tf1 tf1
    file rename -force tf2 tf2
    list [contents tf1] [contents tf2] [file writable tf1] [file writable tf2]
} {tf1 tf2 1 0}    
test filecmd-39.6 {file rename: comprehensive: dir to self} {unixOrPc} {
    cleanup
    file mkdir td1
    file mkdir td2
    testchmod 555 td2
    file rename -force td1 .
    file rename -force td2 .
    list [lsort [glob td*]] [file writable td1] [file writable td2]
} {{td1 td2} 1 0}    
test filecmd-39.7 {file rename: comprehensive: file to existing file} {
    cleanup
    createfile tf1
    createfile tf2
    createfile tfs1
    createfile tfs2
    createfile tfs3
    createfile tfs4
    createfile tfd1
    createfile tfd2
    createfile tfd3
    createfile tfd4
    testchmod 444 tfs3
    testchmod 444 tfs4
    testchmod 444 tfd2
    testchmod 444 tfd4
    set msg [list [catch {file rename tf1 tf2} msg] $msg]
    file rename -force tfs1 tfd1
    file rename -force tfs2 tfd2
    file rename -force tfs3 tfd3
    file rename -force tfs4 tfd4
    list [lsort [glob tf*]] $msg [file writable tfd1] [file writable tfd2] [file writable tfd3] [file writable tfd4] 
} {{tf1 tf2 tfd1 tfd2 tfd3 tfd4} {1 {error renaming "tf1" to "tf2": file already exists}} 1 1 0 0}
test filecmd-39.8 {file rename: comprehensive: dir to empty dir} {
    # Under unix, you can rename a read-only directory, but you can't
    # move it into another directory.

    cleanup
    file mkdir td1
    file mkdir [file join td2 td1]
    file mkdir tds1
    file mkdir tds2
    file mkdir tds3
    file mkdir tds4
    file mkdir [file join tdd1 tds1]
    file mkdir [file join tdd2 tds2]
    file mkdir [file join tdd3 tds3]
    file mkdir [file join tdd4 tds4]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	testchmod 555 tds3
	testchmod 555 tds4
    }
    if {$tcl_platform(platform) != "macintosh"} {
    testchmod 555 [file join tdd2 tds2]
    testchmod 555 [file join tdd4 tds4]
    }
    set msg [list [catch {file rename td1 td2} msg] $msg]
    file rename -force tds1 tdd1
    file rename -force tds2 tdd2
    file rename -force tds3 tdd3
    file rename -force tds4 tdd4
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	set w3 [file writable [file join tdd3 tds3]]
	set w4 [file writable [file join tdd4 tds4]]
    } else {
	set w3 0
	set w4 0
    }
    list [lsort [glob td*]] $msg [file writable [file join tdd1 tds1]] \
    [file writable [file join tdd2 tds2]] $w3 $w4
} [subst {{td1 td2 tdd1 tdd2 tdd3 tdd4} {1 {error renaming "td1" to "[file join td2 td1]": file already exists}} 1 1 0 0}]
test filecmd-39.9 {file rename: comprehensive: dir to non-empty dir} {
    cleanup
    file mkdir tds1
    file mkdir tds2
    file mkdir [file join tdd1 tds1 xxx]
    file mkdir [file join tdd2 tds2 xxx]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	testchmod 555 tds2
    }
    set a1 [list [catch {file rename -force tds1 tdd1} msg] $msg]
    set a2 [list [catch {file rename -force tds2 tdd2} msg] $msg]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	set w2 [file writable tds2]
    } else {
	set w2 0
    }
    list [lsort [glob td*]] $a1 $a2 [file writable tds1] $w2
} [subst {{tdd1 tdd2 tds1 tds2} {1 {error renaming "tds1" to "[file join tdd1 tds1]": file already exists}} {1 {error renaming "tds2" to "[file join tdd2 tds2]": file already exists}} 1 0}]
test filecmd-39.10 {file rename: comprehensive: file to new name and dir} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    testchmod 444 tf2
    file rename tf1 [file join td1 tf3]
    file rename tf2 [file join td1 tf4]
    list [catch {glob tf*}] [lsort [glob [file join td1 t*]]] \
    [file writable [file join td1 tf3]] [file writable [file join td1 tf4]]
} [subst {1 {[file join td1 tf3] [file join td1 tf4]} 1 0}]
test filecmd-39.11 {file rename: comprehensive: dir to new name and dir} {
    cleanup
    file mkdir td1
    file mkdir td2
    file mkdir td3
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	testchmod 555 td2
    }
    file rename td1 [file join td3 td3]
    file rename td2 [file join td3 td4]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	set w4 [file writable [file join td3 td4]]
    } else {
        set w4 0
    }
    list [lsort [glob td*]] [lsort [glob [file join td3 t*]]] \
    [file writable [file join td3 td3]] $w4
} [subst {td3 {[file join td3 td3] [file join td3 td4]} 1 0}]
test filecmd-39.12 {file rename: comprehensive: target exists} {
    cleanup
    file mkdir [file join td1 td2] [file join td2 td1]
    if {$tcl_platform(platform) != "macintosh"} {
    testchmod 555 [file join td2 td1]
    }
    file mkdir [file join td3 td4] [file join td4 td3]
    file rename -force td3 td4
    set msg [list [file exists td3] [file exists [file join td4 td3 td4]] \
    [catch {file rename td1 td2} msg] $msg]
    if {$tcl_platform(platform) != "macintosh"} {
    testchmod 755 [file join td2 td1]
    }
    set msg
} [subst {0 1 1 {error renaming "td1" to "[file join td2 td1]": file already exists}}]
test filecmd-39.13 {file rename: comprehensive: can't overwrite target} {
    cleanup
    file mkdir [file join td1 td2] [file join td2 td1 td4]
    list [catch {file rename -force td1 td2} msg] $msg
} [subst {1 {error renaming "td1" to "[file join td2 td1]": file already exists}}]
test filecmd-39.14 {file rename: comprehensive: dir into self} {
    cleanup
    file mkdir td1
    list [glob td*] [list [catch {file rename td1 td1} msg] $msg]
} [subst {td1 {1 {error renaming "td1" to "[file join td1 td1]": trying to rename a volume or move a directory into itself}}}]
test filecmd-39.15 {file rename: comprehensive: source and target incompatible} {
    cleanup
    file mkdir td1
    createfile tf1
    list [catch {file rename -force td1 tf1} msg] $msg
} {1 {can't overwrite file "tf1" with directory "td1"}}
test filecmd-39.16 {file rename: comprehensive: source and target incompatible} {
    cleanup
    file mkdir td1/tf1
    createfile tf1
    list [catch {file rename -force tf1 td1} msg] $msg
} [subst {1 {can't overwrite directory "[file join td1 tf1]" with file "tf1"}}]

test filecmd-40.1 {file copy: comprehensive: source doesn't exist} {
    cleanup
    list [catch {file copy tf1 tf2} msg] $msg
} {1 {error copying "tf1": no such file or directory}}
test filecmd-40.2 {file copy: comprehensive: file to new name} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    testchmod 444 tf2
    file copy tf1 tf3
    file copy tf2 tf4
    list [lsort [glob tf*]] [contents tf3] [contents tf4] [file writable tf3] [file writable tf4]
} {{tf1 tf2 tf3 tf4} tf1 tf2 1 0}
test filecmd-40.3 {file copy: comprehensive: dir to new name} {unixOrPc} {
    cleanup
    file mkdir [file join td1 tdx]
    file mkdir [file join td2 tdy]
    testchmod 555 td2
    file copy td1 td3
    file copy td2 td4
    set msg [list [lsort [glob td*]] [glob [file join td3 t*]] \
	    [glob [file join td4 t*]] [file writable td3] [file writable td4]]
    if {$tcl_platform(platform) != "macintosh"} {
    testchmod 755 td2
    testchmod 755 td4
    }
    set msg
} [subst {{td1 td2 td3 td4} [file join td3 tdx] [file join td4 tdy] 1 0}]
test filecmd-40.4 {file copy: comprehensive: file to existing file} {
    cleanup
    createfile tf1
    createfile tf2
    createfile tfs1
    createfile tfs2
    createfile tfs3
    createfile tfs4
    createfile tfd1
    createfile tfd2
    createfile tfd3
    createfile tfd4
    testchmod 444 tfs3
    testchmod 444 tfs4
    testchmod 444 tfd2
    testchmod 444 tfd4
    set msg [list [catch {file copy tf1 tf2} msg] $msg]
    file copy -force tfs1 tfd1
    file copy -force tfs2 tfd2
    file copy -force tfs3 tfd3
    file copy -force tfs4 tfd4
    list [lsort [glob tf*]] $msg [file writable tfd1] [file writable tfd2] [file writable tfd3] [file writable tfd4] 
} {{tf1 tf2 tfd1 tfd2 tfd3 tfd4 tfs1 tfs2 tfs3 tfs4} {1 {error copying "tf1" to "tf2": file already exists}} 1 1 0 0}
test filecmd-40.5 {file copy: comprehensive: dir to empty dir} {
    cleanup
    file mkdir td1
    file mkdir [file join td2 td1]
    file mkdir tds1
    file mkdir tds2
    file mkdir tds3
    file mkdir tds4
    file mkdir [file join tdd1 tds1]
    file mkdir [file join tdd2 tds2]
    file mkdir [file join tdd3 tds3]
    file mkdir [file join tdd4 tds4]
    if {$tcl_platform(platform) != "macintosh"} {
    testchmod 555 tds3
    testchmod 555 tds4
    testchmod 555 [file join tdd2 tds2]
    testchmod 555 [file join tdd4 tds4]
    }
    set a1 [list [catch {file copy td1 td2} msg] $msg]
    set a2 [list [catch {file copy -force tds1 tdd1} msg] $msg]
    set a3 [catch {file copy -force tds2 tdd2}]
    set a4 [catch {file copy -force tds3 tdd3}]
    set a5 [catch {file copy -force tds4 tdd4}]
    list [lsort [glob td*]] $a1 $a2 $a3 $a4 $a5 
} [subst {{td1 td2 tdd1 tdd2 tdd3 tdd4 tds1 tds2 tds3 tds4} {1 {error copying "td1" to "[file join td2 td1]": file already exists}} {1 {error copying "tds1" to "[file join tdd1 tds1]": file already exists}} 1 1 1}]
test filecmd-40.6 {file copy: comprehensive: dir to non-empty dir} {unixOrPc} {
    cleanup
    file mkdir tds1
    file mkdir tds2
    file mkdir [file join tdd1 tds1 xxx]
    file mkdir [file join tdd2 tds2 xxx]
    testchmod 555 tds2
    set a1 [list [catch {file copy -force tds1 tdd1} msg] $msg]
    set a2 [list [catch {file copy -force tds2 tdd2} msg] $msg]
    list [lsort [glob td*]] $a1 $a2 [file writable tds1] [file writable tds2]
} [subst {{tdd1 tdd2 tds1 tds2} {1 {error copying "tds1" to "[file join tdd1 tds1]": file already exists}} {1 {error copying "tds2" to "[file join tdd2 tds2]": file already exists}} 1 0}]
test filecmd-40.7 {file rename: comprehensive: file to new name and dir} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    testchmod 444 tf2
    file copy tf1 [file join td1 tf3]
    file copy tf2 [file join td1 tf4]
    list [lsort [glob tf*]] [lsort [glob [file join td1 t*]]] \
    [file writable [file join td1 tf3]] [file writable [file join td1 tf4]]
} [subst {{tf1 tf2} {[file join td1 tf3] [file join td1 tf4]} 1 0}]
test filecmd-40.8 {file rename: comprehensive: dir to new name and dir} {unixOrPc} {
    cleanup
    file mkdir td1
    file mkdir td2
    file mkdir td3
    testchmod 555 td2
    file copy td1 [file join td3 td3]
    file copy td2 [file join td3 td4]
    list [lsort [glob td*]] [lsort [glob [file join td3 t*]]] \
    [file writable [file join td3 td3]] [file writable [file join td3 td4]]
} [subst {{td1 td2 td3} {[file join td3 td3] [file join td3 td4]} 1 0}]
test filecmd-40.9 {file copy: comprehensive: source and target incompatible} {
    cleanup
    file mkdir td1
    createfile tf1
    list [catch {file copy -force td1 tf1} msg] $msg
} {1 {can't overwrite file "tf1" with directory "td1"}}
test filecmd-40.10 {file copy: comprehensive: source and target incompatible} {
    cleanup
    file mkdir [file join td1 tf1]
    createfile tf1
    list [catch {file copy -force tf1 td1} msg] $msg
} [subst {1 {can't overwrite directory "[file join td1 tf1]" with file "tf1"}}]
cleanup    

# old tests    

test filecmd-41.1 {TclFileRenameCmd: -- option } {
    file delete -force -- -tfa1
    set s [createfile -tfa1]
    file rename -- -tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && ![file exists -tfa1]]
    file delete tfa2
    set result
} {1}

test filecmd-41.2 {TclFileRenameCmd: bad option } {
    file delete -force -- tfa1
    set s [createfile tfa1]
    set r1 [catch {file rename -x tfa1 tfa2}]
    set result [expr $r1 && [checkcontent tfa1 $s] && ![file exists tfa2]]
    file delete tfa1
    set result
} {1}

test filecmd-41.3 {TclFileRenameCmd: bad \# args} {
    catch {file rename -- }
} {1}

test filecmd-41.4 {TclFileRenameCmd: target filename translation failing} {
     global env
     set temp $env(HOME)
     unset env(HOME)
     set result [catch {file rename tfa ~/foobar }]
     set env(HOME) $temp
     set result
 } {1}

test filecmd-41.5 {TclFileRenameCmd: more than one source and target is not a directory} {
    file delete -force -- tfa1 tfa2 tfa3
    createfile tfa1 
    createfile tfa2 
    createfile tfa3 
    set result [catch {file rename tfa1 tfa2 tfa3}]
    file delete tfa1 tfa2 tfa3
    set result
} {1}

test filecmd-41.6 {TclFileRenameCmd: : single file into directory  } {
    file delete -force -- tfa1 tfad
    set s [createfile tfa1]
    file mkdir tfad
    file rename tfa1 tfad
    set result [expr [checkcontent tfad/tfa1 $s] && ![file exists tfa1]]
    file delete -force tfad
    set result
} {1}

test filecmd-41.7 {TclFileRenameCmd: : multiple files into directory  } {
    file delete -force -- tfa1 tfa2 tfad
    set s1 [createfile tfa1 ]
    set s2 [createfile tfa2 ]
    file mkdir tfad
    file rename tfa1 tfa2 tfad
    set r1 [checkcontent tfad/tfa1 $s1]
    set r2 [checkcontent tfad/tfa2 $s2]
    
    set result [expr $r1 && $r2 && ![file exists tfa1] && ![file exists tfa2]]
	    
    file delete -force tfad
    set result
} {1}

test filecmd-41.8 {TclFileRenameCmd: error renaming file to directory } {
    file delete -force -- tfa tfad
    set s [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfa $s]
    set r3 [file isdir tfad]
    set result [expr $r1 && $r2 && $r3 ]
    file delete -force tfa tfad
    set result
} {1}

#
# Coverage tests for renamefile() ;
#
test filecmd-42.1 {renamefile: source filename translation failing} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set result [catch {file rename ~/tfa1 tfa2}]
    set env(HOME) $temp
    set result
} {1}

test filecmd-42.2 {renamefile: src filename translation failing} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set s [createfile tfa1]
    file mkdir tfad
    set result [catch {file rename tfa1 ~/tfa2 tfad}]
    set env(HOME) $temp
    file delete -force tfad
    set result
} {1}

test filecmd-42.3 {renamefile: stat failing on source} {
    file delete -force -- tfa1 tfa2
    set r1 [catch {file rename tfa1 tfa2}]
    expr {$r1 && ![file exists tfa1] && ![file exists tfa2]}
} {1}

test filecmd-42.4 {renamefile: error renaming file to directory } {
    file delete -force -- tfa tfad
    set s1 [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfa $s1]
    set r3 [file isdir tfad/tfa]
    set result [expr $r1 && $r2 && $r3]
    file delete -force tfa tfad
    set result
} {1}

test filecmd-42.5 {renamefile: error renaming directory to file } {
    file delete -force -- tfa tfad
    file mkdir tfa
    file mkdir tfad
    set s [createfile tfad/tfa]
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfad/tfa $s]
    set r3 [file isdir tfad]
    set r4 [file isdir tfa]
    set result [expr $r1 && $r2 && $r3 && $r4 ]
    file delete -force tfa tfad
    set result
} {1}

test filecmd-42.6 {renamefile: TclRenameFile succeeding } {
    file delete -force -- tfa1 tfa2
    set s [createfile tfa1]
    file rename tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && ![file exists tfa1]]
    file delete tfa2
    set result
} {1}

test filecmd-42.7 {renamefile: renaming directory into offspring} {
    file delete -force -- tfad
    file mkdir tfad
    file mkdir tfad/dir
    set result [catch {file rename tfad tfad/dir}]
    file delete -force tfad 
    set result
} {1}

test filecmd-42.8 {renamefile: generic error } {unixOnly} {
    file delete -force -- tfa
    file mkdir tfa
    file mkdir tfa/dir
    exec chmod 555 tfa
    set result [catch {file rename tfa/dir tfa2}]
    exec chmod 777 tfa
    file delete -force tfa
    set result
} {1}


test filecmd-42.9 {renamefile: moving a file across volumes } {unixOnly} {
    file delete -force -- tfa /tmp/tfa
    set s [createfile tfa ]
    file rename tfa /tmp
    set result [expr [checkcontent /tmp/tfa $s] && ![file exists tfa]]
    file delete /tmp/tfa
    set result
} {1}

test filecmd-42.10 {renamefile: moving a directory across volumes } {unixOnly} {
    file delete -force -- tfad /tmp/tfad
    file mkdir tfad
    set s [createfile tfad/a ]
    file rename tfad /tmp
    set restul [expr [checkcontent /tmp/tfad/a $s] && ![file exists tfad]]
    file delete -force /tmp/tfad
    set result
} {1}

#
# Coverage tests for TclCopyFilesCmd()
#
test filecmd-43.1 {TclCopyFilesCmd: -force option } {
    file delete -force -- tfa1
    set s [createfile tfa1]
    file copy -force  tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && [checkcontent tfa1 $s]]
    file delete tfa1 tfa2
    set result
} {1}

test filecmd-43.2 {TclCopyFilesCmd: -- option } {
    file delete -force -- tfa1
    set s [createfile -tfa1]
    file copy --  -tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] &&  [checkcontent -tfa1 $s]]
    file delete -- -tfa1 tfa2
    set result
} {1}

test filecmd-43.3 {TclCopyFilesCmd: bad option } {
    file delete -force -- tfa1
    set s [createfile tfa1]
    set r1 [catch {file copy -x tfa1 tfa2}]
    set result [expr $r1 && [checkcontent tfa1 $s] && ![file exists tfa2]]
    file delete tfa1
    set result
} {1}

test filecmd-43.4 {TclCopyFilesCmd: bad \# args} {
    catch {file copy -- }
} {1}

test filecmd-43.5 {TclCopyFilesCmd: target filename translation failing} {
     global env
     set temp $env(HOME)
    unset env(HOME)
     set result [catch {file copy tfa ~/foobar }]
     set env(HOME) $temp
     set result
 } {1}

test filecmd-43.6 {TclCopyFilesCmd: more than one source and target is not a directory} {
    file delete -force -- tfa1 tfa2 tfa3
    createfile tfa1 
    createfile tfa2 
    createfile tfa3 
    set result [catch {file copy tfa1 tfa2 tfa3}]
    file delete tfa1 tfa2 tfa3
    set result
} {1}

test filecmd-43.7 {TclCopyFilesCmd: : single file into directory  } {
    file delete -force -- tfa1 tfad
    set s [createfile tfa1]
    file mkdir tfad
    file copy tfa1 tfad
    set result [expr [checkcontent tfad/tfa1 $s] &&  [checkcontent tfa1 $s]]
    file delete -force tfad tfa1
    set result
} {1}

test filecmd-43.8 {TclCopyFilesCmd: : multiple files into directory  } {
    file delete -force -- tfa1 tfa2 tfad
    set s1 [createfile tfa1 ]
    set s2 [createfile tfa2 ]
    file mkdir tfad
    file copy tfa1 tfa2 tfad
    set r1 [checkcontent tfad/tfa1 $s1]
    set r2 [checkcontent tfad/tfa2 $s2]
    set r3 [checkcontent tfa1 $s1]
    set r4 [checkcontent tfa2 $s2]
    set result [expr $r1 && $r2 && $r3 && $r4 ]
	    
    file delete -force tfad tfa1 tfa2
    set result
} {1}

test filecmd-43.9 {TclCopyFilesCmd: error copying file to directory } {
    file delete -force -- tfa tfad
    set s [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file copy tfa tfad}]
    set r2 [expr [checkcontent tfa $s] && [file isdir tfad/tfa]]
    set r3 [file isdir tfad]
    set result [expr $r1 && $r2 && $r3 ]
    file delete -force tfa tfad
    set result
} {1}

#
# Coverage tests for copyfile()
# 
test filecmd-44.1 {copyfile: source filename translation failing} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set result [catch {file copy ~/tfa1 tfa2}]
    set env(HOME) $temp
    set result
} {1}

test filecmd-44.2 {copyfile: dst filename translation failing} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set s [createfile tfa1]
    file mkdir tfad
    set r1 [catch {file copy tfa1 ~/tfa2 tfad}]
    set result [expr $r1 && [checkcontent tfad/tfa1 $s]]
    set env(HOME) $temp
    file delete -force tfa1 tfad
    set result
} {1}

test filecmd-44.3 {copyfile: stat failing on source} {
    file delete -force -- tfa1 tfa2
    set r1 [catch {file copy tfa1 tfa2}]
    expr $r1 && ![file exists tfa1] && ![file exists tfa2]
} {1}

test filecmd-44.4 {copyfile: error copying file to directory } {
    file delete -force -- tfa tfad
    set s1 [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file copy tfa tfad}]
    set r2 [checkcontent tfa $s1]
    set r3 [file isdir tfad]
    set r4 [file isdir tfad/tfa]
    set result [expr $r1 && $r2 && $r3 && $r4 ]
    file delete -force tfa tfad
    set result
} {1}

 test filecmd-44.5 {copyfile: error copying directory to file } {
     file delete -force -- tfa tfad
     file mkdir tfa
     file mkdir tfad
     set s [createfile tfad/tfa]
     set r1 [catch {file copy tfa tfad}]
     set r2 [checkcontent tfad/tfa $s]
     set r3 [file isdir tfad]
     set r4 [file isdir tfa]
     set result [expr $r1 && $r2 && $r3 && $r4 ]
     file delete -force tfa tfad
     set result
} {1}

test filecmd-44.6 {copyfile: copy file succeeding } {
    file delete -force -- tfa tfa2
    set s [createfile tfa]
    file copy tfa tfa2
    set result [expr  [checkcontent tfa $s] && [checkcontent tfa2 $s]]
    file delete tfa tfa2
    set result
} {1}

test filecmd-44.7 {copyfile: copy directory succeeding } {
    file delete -force -- tfa tfa2
    file mkdir tfa
    set s [createfile tfa/file]
    file copy tfa tfa2
    set result [expr [checkcontent tfa/file $s] && [checkcontent tfa2/file $s]]
    file delete -force tfa tfa2
    set result
} {1}

test filecmd-44.8 {copyfile: copy directory failing } {unixOnly} {
    file delete -force -- tfa 
    file mkdir tfa/dir/a/b/c
    exec chmod 000 tfa/dir
    set r1 [catch {file copy tfa tfa2}]
    exec chmod 777 tfa/dir
    set result $r1
    file delete -force tfa tfa2
    set result
} {1}
#
# Coverage tests for TclMkdirCmd()
#
test filecmd-45.1 {TclMakeDirsCmd: target filename translation failing} {
    global env
    set temp $env(HOME)
    unset env(HOME) 
    set result [catch {file mkdir ~/tfa}]
    set env(HOME) $temp
    set result
} {1}
#
# Can Tcl_SplitPath return argc == 0? If so them we need a
# test for that code.
#
test filecmd-45.2 {TclMakeDirsCmd - one directory } {
    file delete -force -- tfa
    file mkdir tfa
    set result [file isdirectory tfa]
    file delete tfa
    set result
} {1}

test filecmd-45.3 {TclMakeDirsCmd: - two directories } {
    file delete -force -- tfa1 tfa2
    file mkdir tfa1 tfa2
    set result [expr [file isdirectory tfa1] && [file isdirectory tfa2]]
    file delete tfa1 tfa2
    set result
} {1}

test filecmd-45.4 {TclMakeDirsCmd - stat failing } {unixOnly} {
    file delete -force -- tfa
    file mkdir tfa
    createfile tfa/file
    exec chmod 000 tfa
    set result [catch {file mkdir tfa/file}]
    exec chmod 777 tfa
    file delete -force tfa
    set result
} {1}

test filecmd-45.5 {TclMakeDirsCmd: - making a directory several levels deep } {
    file delete -force -- tfa
    file mkdir tfa/a/b/c
    set result [file isdir tfa/a/b/c]
    file delete -force tfa
    set result
} {1}

    
test filecmd-45.6 {TclMakeDirsCmd: - trying to overwrite a file } {
    file delete -force -- tfa
    set s [createfile tfa]
    set r1 [catch {file mkdir tfa}]
    set r2 [file isdir tfa]
    set r3 [file exists tfa]
    set result [expr $r1 && !$r2 && $r3 && [checkcontent tfa $s]]
    file delete tfa
    set result
} {1}

test filecmd-45.7 {TclMakeDirsCmd - making several directories } {
    file delete -force -- tfa1 tfa2
    file mkdir tfa1 tfa2/a/b/c
    set result [expr [file isdir tfa1] && [file isdir tfa2/a/b/c]]
    file delete -force tfa1 tfa2
    set result
} {1}

test filecmd-45.8 {TclFileMakeDirsCmd: trying to create an existing dir} {
    file mkdir tfa
    file mkdir tfa
    set result [file isdir tfa]
    file delete tfa
    set result
} {1}


# Coverage tests for TclDeleteFilesCommand()
test filecmd-46.1 { test the -- argument } {
    file delete -force -- tfa
    createfile tfa
    file delete -- tfa
    file exists tfa
} {0}

test filecmd-46.2 { test the -force and -- arguments } {
    file delete -force -- tfa
    createfile tfa
    file delete -force -- tfa
    file exists tfa
} {0}

test filecmd-46.3 { test bad option } {
    file delete -force -- tfa
    createfile tfa
    set result [catch {file delete -dog tfa}]
    file delete tfa
    set result
} {1}

test filecmd-46.4 { test not enough args } {
    catch {file delete}
} {1}

test filecmd-46.5 { test not enough args with options } {
    catch {file delete --}
} {1}

test filecmd-46.6 {delete: source filename translation failing} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set result [catch {file delete ~/tfa}]
    set env(HOME) $temp
    set result
} {1}

test filecmd-46.7 {remove a non-empty directory without -force } {
    file delete -force -- tfa
    file mkdir tfa
    createfile tfa/a
    set result [catch  {file delete tfa }]
    file delete -force tfa
    set result
} {1}

test filecmd-46.8 {remove a normal file } {
    file delete -force -- tfa
    file mkdir tfa
    createfile tfa/a
    set result [catch  {file delete tfa }]
    file delete -force tfa
    set result
} {1}

test filecmd-46.9 {error while deleting file } {unixOnly} {
    file delete -force -- tfa
    file mkdir tfa
    createfile tfa/a
    exec chmod 555 tfa
    set result [catch  {file delete tfa/a }]
    #######
    #######  If any directory in a tree that is being removed does not 
    #######  have write permission, the process will fail!
    #######  This is also the case with "rm -rf"
    #######
    exec chmod 777 tfa
    file delete -force tfa
    set result
} {1}

test filecmd-46.10 {deleting multiple files } {
    file delete -force -- tfa1 tfa2
    createfile tfa1
    createfile tfa2
    file delete tfa1 tfa2
    expr ![file exists tfa1] && ![file exists tfa2]
} {1}

test filecmd-46.11 { TclFileDeleteCmd: removing a nonexistant file} {
    file delete -force -- tfa
    file delete tfa
    set result 1
} {1}

# More coverage tests for mkpath()
 test filecmd-47.1 {mkdir stat failing on target but not ENOENT } {unixOnly} {
     file delete -force -- tfa1
     file mkdir tfa1
     exec chmod 555 tfa1
     set result [catch {file mkdir tfa1/tfa2}]
     exec chmod 777 tfa1
     file delete -force tfa1
     set result
} {1}

test filecmd-47.2 {mkdir several levels deep - relative } {
    file delete -force -- tfa
    file mkdir tfa/a/b
    set result [file isdir tfa/a/b ]
    file delete tfa/a/b tfa/a tfa
    set result
} {1}

test filecmd-47.3 {mkdir several levels deep - absolute } {
    file delete -force -- tfa
    set f [file join [pwd] tfa a ]
    file mkdir $f
    set result [file isdir $f ]
    file delete $f [file join [pwd] tfa]
    set result
} {1}

#
# Functionality tests for TclFileRenameCmd()
#

test filecmd-48.1 {TclFileRenameCmd: rename (first form) in the same directory} {
    file delete -force -- tfad
    file mkdir tfad/dir
    cd tfad/dir
    set s [createfile foo ]
    file rename  foo bar
    file rename bar ./foo
    file rename ./foo bar
    file rename ./bar ./foo
    file rename foo ../dir/bar
    file rename ../dir/bar ./foo
    file rename ../../tfad/dir/foo ../../tfad/dir/bar
    file rename [file join [pwd] bar] foo
    file rename foo [file join [pwd] bar]
    set result [expr [checkcontent bar $s] && ![file exists foo]]
    cd ../..
    file delete -force tfad
    set result
} {1}

test filecmd-48.2 {TclFileRenameCmd: single dir to nonexistant } {
    file delete -force -- tfa1 tfa2
    file mkdir tfa1
    file rename tfa1 tfa2
    set result [expr [file exists tfa2] && ![file exists tfa1]]
    file delete tfa2
    set result
} {1}

test filecmd-48.3 {TclFileRenameCmd: mixed dirs and files into directory  } {
    file delete -force -- tfa1 tfad1 tfad2
    set s [createfile tfa1 ]
    file mkdir tfad1 tfad2
    file rename tfa1 tfad1 tfad2
    set r1 [checkcontent  tfad2/tfa1 $s]
    set r2 [file isdir tfad2/tfad1]
    set result [expr $r1 && $r2 && ![file exists tfa1] && ![file exists tfad1]]
    file delete tfad2/tfa1
    file delete -force tfad2
    set result
} {1}

test filecmd-48.4 {TclFileRenameCmd: attempt to replace non-dir with dir } {
    file delete -force -- tfa tfad
    set s [createfile tfa ]
    file mkdir tfad
    set r1 [catch {file rename tfad tfa}]
    set r2 [checkcontent tfa $s]
    set r3 [file isdir tfad]
    set result [expr $r1 && $r2 && $r3 ]
    file delete tfa tfad
    set result
} {1}

test filecmd-48.5 {TclFileRenameCmd: attempt to replace dir with non-dir } {
    file delete -force -- tfa tfad
    set s [createfile tfa ]
    file mkdir tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfa $s]
    set r3 [file isdir tfad/tfa]
    set result [expr $r1 && $r2 && $r3 ]
    file delete -force  tfa tfad
    set result
} {1}

#
# On Windows there is no easy way to determine if two files are the same
#
test filecmd-48.6 {TclFileRenameCmd: rename a file to itself} {macOrUnix}  {
    file delete -force -- tfa
    set s [createfile tfa]
    set r1 [catch {file rename tfa tfa}]
    set result [expr $r1 && [checkcontent tfa $s]]
    file delete tfa
    set result
} {1}

test filecmd-48.7 {TclFileRenameCmd: rename dir on top of another empty dir w/o -force} {
    file delete -force -- tfa tfad
    file mkdir tfa tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set result [expr $r1 && [file isdir tfa]]
    file delete -force tfa tfad
    set result
} {1}

test filecmd-48.8 {TclFileRenameCmd: rename dir on top of another empty dir w/ -force} {
    file delete -force -- tfa tfad
    file mkdir tfa tfad/tfa
    file rename -force tfa tfad
    set result [expr ![file isdir tfa]]
    file delete -force tfad
    set result
} {1}

test filecmd-48.9 {TclFileRenameCmd: rename dir on top of a non-empty dir w/o -force} {
    file delete -force -- tfa tfad
    file mkdir tfa tfad/tfa/file
    set r1 [catch {file rename tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir tfad/tfa/file]]
    file delete -force tfa tfad
    set result
} {1}

test filecmd-48.10 {TclFileRenameCmd: rename dir on top of a non-empty dir w/ -force} {
    file delete -force -- tfa tfad
    file mkdir tfa tfad/tfa/file
    set r1 [catch {file rename -force tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir tfad/tfa/file]]
    file delete -force tfa tfad
    set result
} {1}

test filecmd-48.11 {TclFileRenameCmd: rename a non-existant file} {
    file delete -force -- tfa1
    set r1 [catch {file rename tfa1 tfa2}]
    set result [expr $r1 && ![file exists tfa1] && ![file exists tfa2]]
} {1}

test filecmd-48.12 {TclFileRenameCmd : rename a symbolic link to file} {unixOnly} {
    file delete -force -- tfa1 tfa2 tfa3
	
    set s [createfile tfa1]
    exec ln -s tfa1 tfa2
    file rename tfa2 tfa3
    set t [file type tfa3]
    set result [expr { $t == "link" }]
    file delete tfa1 tfa3
    set result
} {1}

test filecmd-48.13 {TclFileRenameCmd : rename a symbolic link to dir} {unixOnly} {
    file delete -force -- tfa1 tfa2 tfa3
	
    file mkdir tfa1
    exec ln -s tfa1 tfa2
    file rename tfa2 tfa3
    set t [file type tfa3]
    set result [expr { $t == "link" }]
    file delete tfa1 tfa3
    set result
} {1}

test filecmd-48.14 {TclFileRenameCmd : rename a path with sym link} {unixOnly} {
    file delete -force -- tfa1 tfa2 tfa3
	
    file mkdir tfa1/a/b/c/d
    file mkdir tfa2
    set f [file join [pwd] tfa1/a/b] 
    set f2 [file join [pwd] {tfa2/b alias}]
    exec ln -s $f $f2
    file rename {tfa2/b alias/c} tfa3
    set r1 [file isdir tfa3]
    set r2 [file exists tfa1/a/b/c]
    set result [expr $r1 && !$r2]
    file delete -force tfa1 tfa2 tfa3
    set result
} {1}

test filecmd-48.15 {TclFileRenameCmd : rename a file to a symlink dir} {unixOnly} {
    file delete -force -- tfa1 tfa2 tfalink
	
    file mkdir tfa1
    set s [createfile tfa2]
    exec ln -s tfa1 tfalink

    file rename tfa2 tfalink
    set result [checkcontent tfa1/tfa2 $s ]
    file delete -force tfa1 tfalink
    set result
} {1}

test filecmd-48.16 {TclFileRenameCmd : rename a dangling symlink} {unixOnly} {
    file delete -force -- tfa1 tfalink
	
    file mkdir tfa1
    exec ln -s tfa1 tfalink
    file delete tfa1 
    file rename tfalink tfa2
    set result [expr [string compare [file type tfa2] "link"] == 0]
    file delete tfa2
    set result
} {1}


#
# Coverage tests for TclUnixRmdir
#
test filecmd-49.1 { remove empty directory } {
    file delete -force -- tfa
    file mkdir tfa
    file delete tfa
    file exists tfa
} {0}

test filecmd-49.2 { rmdir error besides EEXIST} {unixOnly} {
    file delete -force -- tfa
    file mkdir tfa
    file mkdir tfa/a
    exec chmod 555 tfa
    set result [catch {file delete tfa/a}]
    exec chmod 777 tfa
    file delete -force tfa
    set result
} {1}

test filecmd-49.3 { recursive remove } {
    file delete -force -- tfa
    file mkdir tfa
    file mkdir tfa/a
    file delete -force tfa
    file exists tfa
} {0}

#
# TclUnixDeleteFile and TraversalDelete are covered by tests from the 
# TclDeleteFilesCmd suite
#
#

#
# Coverage tests for TraverseUnixTree(), called from TclDeleteFilesCmd
#

test filecmd-50.1 {TraverseUnixTree : failure opening a subdirectory directory } {unixOnly} {
    file delete -force -- tfa
    file mkdir tfa
    file mkdir tfa/a
    exec chmod 000 tfa/a
    set result [catch {file delete -force tfa}]
    exec chmod 777 tfa/a
    file delete -force tfa
    set result
} {1}


#
# Feature testing for TclCopyFilesCmd
# 
test filecmd-51.1 {copy : single file to nonexistant } {
    file delete -force -- tfa1 tfa2
    set s [createfile tfa1]
    file copy tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && [checkcontent tfa1 $s]]
    file delete tfa1 tfa2
    set result
} {1}

test filecmd-51.2 {copy : single dir to nonexistant } {
    file delete -force -- tfa1 tfa2
    file mkdir tfa1
    file copy tfa1 tfa2
    set result [expr [file isdir tfa2] && [file isdir tfa1]]
    file delete tfa1 tfa2
    set result
} {1}

test filecmd-51.3 {copy : single file into directory  } {
    file delete -force -- tfa1 tfad
    set s [createfile tfa1]
    file mkdir tfad
    file copy tfa1 tfad
    set result [expr [checkcontent tfad/tfa1 $s] && [checkcontent tfa1 $s]]
    file delete -force tfa1 tfad
    set result
} {1}

test filecmd-51.4 {copy : more than one source and target is not a directory} {
    file delete -force -- tfa1 tfa2 tfa3
    createfile tfa1 
    createfile tfa2 
    createfile tfa3 
    set result [catch {file copy tfa1 tfa2 tfa3}]
    file delete tfa1 tfa2 tfa3
    set result
} {1}

test filecmd-51.5 {copy : multiple files into directory  } {
    file delete -force -- tfa1 tfa2 tfad
    set s1 [createfile tfa1 ]
    set s2 [createfile tfa2 ]
    file mkdir tfad
    file copy tfa1 tfa2 tfad
    set r1 [checkcontent tfad/tfa1 $s1]
    set r2 [checkcontent tfad/tfa2 $s2]
    set r3 [checkcontent tfa1 $s1]
    set r4 [checkcontent tfa2 $s2]
    set result [expr $r1 && $r2 && $r3 && $r4]
    file delete -force tfa1 tfa2 tfad
    set result
} {1}

test filecmd-51.6 {copy : mixed dirs and files into directory  } {
    file delete -force -- tfa1 tfad1 tfad2
    set s [createfile tfa1 ]
    file mkdir tfad1 tfad2
    file copy tfa1 tfad1 tfad2
    set r1 [checkcontent  tfad2/tfa1 $s]
    set r2 [file isdir tfad2/tfad1]
    set r3 [checkcontent tfa1 $s]
    set result [expr $r1 && $r2 && $r3 && [file isdir tfad1]]
    file delete -force tfa1 tfad1 tfad2
    set result
} {1}

test filecmd-51.7 {TclCopyFilesCmd : copy a dangling link } {unixOnly} {
    file mkdir tfad1
    exec ln -s tfad1 tfalink
    file delete tfad1
    file copy tfalink tfalink2
    set result [string match [file type tfalink2] link]
    file delete tfalink tfalink2 
    set result
} {1}

test filecmd-51.8 {TclCopyFilesCmd : copy a link } {unixOnly} {
    file mkdir tfad1
    exec ln -s tfad1 tfalink
    file copy tfalink tfalink2
    set r1 [file type tfalink]
    set r2 [file type tfalink2]
    set r3 [file isdir tfad1]
    set result [expr {("$r1" == "link" ) && ("$r2" == "link" ) && $r3}]
    file delete tfad1 tfalink tfalink2
    set result
} {1}

test filecmd-51.9 {TclCopyFilesCmd : copy dir with a link in it } {unixOnly} {
    file mkdir tfad1
    exec ln -s "[pwd]/tfad1" tfad1/tfalink
    file copy tfad1 tfad2
    set result [string match [file type tfad2/tfalink] link]
    file delete -force tfad1 tfad2
    set result
} {1}

test filecmd-51.10 {TclFileCopyCmd: copy dir on top of another empty dir w/o -force} {
    file delete -force -- tfa tfad
    file mkdir tfa tfad/tfa
    set r1 [catch {file copy tfa tfad}]
    set result [expr $r1 && [file isdir tfa]]
    file delete -force tfa tfad
    set result
} {1}

test filecmd-51.11 {TclFileCopyCmd: copy dir on top of a dir w/o -force} {
    file delete -force -- tfa tfad
    file mkdir tfa tfad/tfa/file
    set r1 [catch {file copy tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir tfad/tfa/file]]
    file delete -force tfa tfad
    set result
} {1}

test filecmd-51.12 {TclFileCopyCmd: copy dir on top of a non-empty dir w/ -force} {
    file delete -force -- tfa tfad
    file mkdir tfa tfad/tfa/file
    set r1 [catch {file copy -force tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir tfad/tfa/file]]
    file delete -force tfa tfad
    set result
} {1}
   
# temporary early return
# the rest of the file contains mac tests
cleanup
return
   
#
# Coverage testing for TclMacRenameFile
#
test filecmd-52.1 { TclMacRenameFile : rename and overwrite in a single dir } {
	file delete -force -- tfa1 tfa2
	set s [createfile tfa1]
	set s2 [createfile tfa2 q]
	
	set r1 [catch {rename tfa1 tfa2}]
	file rename -force tfa1 tfa2
	set result [expr $r1 && [checkcontent tfa2 $s]]
	file delete [glob tfa1 tfa2]
	set result
} {1}

test filecmd-52.2 { TclMacRenameFile : attempt to overwrite itself } {macOrUnix} {
	file delete -force -- tfa1 
	set s [createfile tfa1]	
	file rename -force tfa1 tfa1
	set result [checkcontent tfa1 $s]
	file delete tfa1 
	set result
} {1}

test filecmd-52.3 { TclMacRenameFile : rename dir to existing dir } {
	file delete -force -- d1 tfad
	file mkdir d1 tfad/d1
	set r1 [catch {file rename d1 tfad}]
	set result [expr $r1 && [file isdir d1] && [file isdir tfad/d1]]
	file delete -force d1 tfad
	set result
} {1}

test filecmd-52.4 { TclMacRenameFile : rename dir to dir several levels deep } {
	file delete -force -- d1 tfad
	file mkdir d1 tfad/a/b/c
	file rename d1 tfad/a/b/c
	set result [expr ![file isdir d1] && [file isdir tfad/a/b/c/d1]]
	file delete -force [glob d1 tfad]
	set result
} {1}


#
# TclMacCopyFile needs to be redone.
#
test filecmd-52.5 { TclMacCopyFile : copy and overwrite in a single dir } {
	file delete -force -- tfa1 tfa2
	set s [createfile tfa1]
	set s2 [createfile tfa2 q]
	
	set r1 [catch {file copy tfa1 tfa2}]
	file copy -force tfa1 tfa2
	set result [expr $r1 && [checkcontent tfa2 $s] && [checkcontent tfa1 $s]]
	file delete tfa1 tfa2
	set result
} {1}

#
# TclMacMkdir - basic cases are covered elsewhere.
# Error cases are not covered.
#

#
# TclMacRmdir
# Error cases are not covered.
#

test filecmd-53.1 { TclMacRmdir : trying to remove a nonempty directory } {
	file delete -force -- tfad
	
	file mkdir tfad/dir
	
	set result [catch {file delete tfad}]
	file delete -force tfad 
	set result
} {1}

#
# TclMacDeleteFile	
# Error cases are not covered.
#
test filecmd-54.1 { TclMacDeleteFile : deleting a normal file } {
	file delete -force -- tfa1
	
	createfile tfa1
	file delete tfa1
	file exists tfa1
} {0}

#
# TclMacCopyDirectory
# Error cases are not covered.
#
test filecmd-55.1 { TclMacCopyDirectory : copying a normal directory} {
	file delete -force -- tfad1 tfad2
		
	file mkdir tfad1/a/b/c
	file copy tfad1 tfad2
	set result [expr [file isdir tfad1/a/b/c] && [file isdir tfad2/a/b/c]]
	file delete -force tfad1 tfad2
	set result
} {1}

test filecmd-55.2 { TclMacCopyDirectory : copying a short path normal directory} {
	file delete -force -- tfad1 tfad2
		
	file mkdir tfad1
	file copy tfad1 tfad2
	set result [expr [file isdir tfad1] && [file isdir tfad2]]
	file delete tfad1 tfad2
	set result
} {1}

test filecmd-55.3 { TclMacCopyDirectory : copying dirs between different dirs} {
	file delete -force -- tfad1 tfad2
		
	file mkdir tfad1/x/y/z
	file mkdir tfad2/dir
	file copy tfad1 tfad2/dir
	set result [expr [file isdir tfad1/x/y/z] && [file isdir tfad2/dir/tfad1/x/y/z]]
	file delete -force tfad1 tfad2
	set result
} {1}

#
# Functionality tests for TclDeleteFilesCmd
#

test filecmd-56.1 { TclDeleteFilesCmd : delete symlink} {unixOnly} {
    file delete -force -- tfad1 tfad2
		
    file mkdir tfad1
    exec ln -s tfad1 tfalink
    file delete tfalink

    set r1 [file isdir tfad1]
    set r2 [file exists tfalink]
    
    set result [expr $r1 && !$r2]
    file delete tfad1
    set result
} {1}

test filecmd-56.2 { TclDeleteFilesCmd : delete dir with symlink} {unixOnly} {
    file delete -force -- tfad1 tfad2
		
    file mkdir tfad1
    file mkdir tfad2
    exec ln -s tfad1 tfad2/link
    file delete -force tfad2

    set r1 [file isdir tfad1]
    set r2 [file exists tfad2]
    
    set result [expr $r1 && !$r2]
    file delete tfad1
    set result
} {1}

test filecmd-56.3 { TclDeleteFilesCmd : delete dangling symlink} {unixOnly} {
    file delete -force -- tfad1 tfad2
		
    file mkdir tfad1
    exec ln -s tfad1 tfad2
    file delete tfad1
    file delete tfad2

    set r1 [file exists tfad1]
    set r2 [file exists tfad2]
    
    set result [expr !$r1 && !$r2]
    set result
} {1}


# cleanup
cleanup
concat ""

::tcltest::cleanupTests
return
