# Commands covered: expr
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands. Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: expr.test,v 1.15 2006/05/13 21:07:15 mdejong Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

testConstraint registeredMathFuncs [expr {
    ([catch {expr T1()} msg] != 1) || ($msg ne {unknown math function "T1"})
}]

testConstraint wideMathFunc [expr {
    ([catch {expr wide(1)} msg] != 1) || ($msg ne {unknown math function "wide"})
}]

# Determine if "long int" type is a 32 bit number and if the wide
# type is a 64 bit number on this machine.

testConstraint longis32bit [expr {(0x7FFFFFFF + 1) eq (0 - 0x80000000)}]
testConstraint wideis64bit [expr {" 0x8000000000000000 " == "0x8000000000000000"}]

# procedures used below

proc put_hello_char {c} {
    global a
    append a [format %c $c]
    return $c
}
proc hello_world {} {
    global a
    set a ""
    set L1 [set l0 [set h_1 [set q 0]]]
    for {put_hello_char [expr [put_hello_char [expr [set h 7]*10+2]]+29]} {$l0?[put_hello_char $l0]
        :!$h_1} {put_hello_char $ll;expr {$L1==2?[set ll [expr 32+0-0+[set bar 0]]]:0}} {expr {[incr L1]==[expr 1+([string length "abc"]-[string length "abc"])]
        ?[set ll [set l0 [expr 54<<1]]]:$ll==108&&$L1<3?
        [incr ll [expr 1|1<<1]; set ll $ll; set ll $ll; set ll $ll; set ll $ll; set l0 [expr ([string length "abc"]-[string length "abc"])+([string length "abc"]-[string length "abc"])-([string length "abc"]-[string length "abc"])+([string length "abc"]-[string length "abc"])]; set l0; set l0 $l0; set l0; set l0]:$L1==4&&$ll==32?[set ll [expr 19+$h1+([string length "abc"]-[string length "abc"])-([string length "abc"]-[string length "abc"])+([string length "abc"]-[string length "abc"])-([string length "abc"]-[string length "abc"])+[set foo [expr ([string length "abc"]-[string length "abc"])+([string length "abc"]-[string length "abc"])+([string length "abc"]-[string length "abc"])]]]]
        :[set q [expr $q-$h1+([string length "abc"]-[string length "abc"])-([string length "abc"]-[string length "abc"])]]};expr {$L1==5?[incr ll -8; set ll $ll; set ll]:$q&&$h1&&1};expr {$L1==4+2
        ?[incr ll 3]:[expr ([string length "abc"]-[string length "abc"])+1]};expr {$ll==($h<<4)+2+0&&$L1!=6?[incr ll -6]:[set h1 [expr 100+([string length "abc"]-[string length "abc"])-([string length "abc"]-[string length "abc"])]]}
        expr {$L1!=1<<3?[incr q [expr ([string length "abc"]-[string length "abc"])-1]]:[set h_1 [set ll $h1]]}
    }
    set a
}

proc 12days {a b c} {
    global xxx
    expr {1<$a?[expr {$a<3?[12days -79 -13 [string range $c [12days -87 \
	[expr 1-$b] [string range $c [12days -86 0 [string range $c 1 end]] \
	end]] end]]:1};expr {$a<$b?[12days [expr $a+1] $b $c]:3};expr {[12days \
	-94 [expr $a-27] $c]&&$a==2?$b<13?[12days 2 [expr $b+1] "%s %d %d\n"]:9
	:16}]:$a<0?$a<-72?[12days $b $a "@n'+,#'/*\{\}w+/w#cdnr/+,\{\}r/*de\}+,/*\{*+,/w\{%+,/w#q#n+,/#\{l+,/n\{n+,/+#n+,/#;#q#n+,/+k#;*+,/'r :'d*'3,\}\{w+K w'K:'+\}e#';dq#'l q#'+d'K#!/+k#;q#'r\}eKK#\}w'r\}eKK\{nl\]'/#;#q#n')\{)#\}w')\{)\{nl\]'/+#n';d\}rw' i;# )\{nl\]!/n\{n#'; r\{#w'r nc\{nl\]'/#\{l,+'K \{rw' iK\{;\[\{nl\]'/w#q#n'wk nw' iwk\{KK\{nl\]!/w\{%'l##w#' i; :\{nl\]'/*\{q#'ld;r'\}\{nlwb!/*de\}'c ;;\{nl'-\{\}rw\]'/+,\}##'*\}#nc,',#nw\]'/+kd'+e\}+;#'rdq#w! nr'/ ') \}+\}\{rl#'\{n' ')# \}'+\}##(!!/"]
	:$a<-50?[string compare [format %c $b] [string index $c 0]]==0?[append \
	xxx [string index $c 31];scan [string index $c 31] %c x;set x]
	:[12days -65 $b [string range $c 1 end]]:[12days [expr ([string compare \
	[string index $c 0] "/"]==0)+$a] $b [string range $c 1 end]]:0<$a
	?[12days 2 2 "%s"]:[string compare [string index $c 0] "/"]==0||
	[12days 0 [12days -61 [scan [string index $c 0] %c x; set x] \
	"!ek;dc i@bK'(q)-\[w\]*%n+r3#l,\{\}:\nuwloca-O;m .vpbks,fxntdCeghiry"] \
	[string range $c 1 end]]}
}
proc do_twelve_days {} {
    global xxx
    set xxx ""
    12days 1 1 1
    string length $xxx
}

# start of tests

catch {unset a b i x}

test expr-1.1 {TclCompileExprCmd: no expression} {
    list [catch {expr  } msg] $msg
} {1 {wrong # args: should be "expr arg ?arg ...?"}}
test expr-1.2 {TclCompileExprCmd: one expression word} {
    expr -25
} -25
test expr-1.3 {TclCompileExprCmd: two expression words} {
    expr -8.2   -6
} -14.2
test expr-1.4 {TclCompileExprCmd: five expression words} {
    expr 20 - 5 +10 -7
} 18
test expr-1.5 {TclCompileExprCmd: quoted expression word} {
    expr "0005"
} 5
test expr-1.6 {TclCompileExprCmd: quoted expression word} {
    catch {expr "0005"zxy} msg
    set msg
} {extra characters after close-quote}
test expr-1.7 {TclCompileExprCmd: expression word in braces} {
    expr {-0005}
} -5
test expr-1.8 {TclCompileExprCmd: expression word in braces} {
    expr {{-0x1234}}
} -4660
test expr-1.9 {TclCompileExprCmd: expression word in braces} {
    catch {expr {-0005}foo} msg
    set msg
} {extra characters after close-brace}
test expr-1.10 {TclCompileExprCmd: other expression word in braces} {
    expr 4*[llength "6 2"]
} 8
test expr-1.11 {TclCompileExprCmd: expression word terminated by ;} {
    expr 4*[llength "6 2"];
} 8
test expr-1.12 {TclCompileExprCmd: inlined expr (in "catch") inside other catch} {
    set a xxx
    catch {
	# Might not be a number
	set a [expr 10*$a]
    }
} 1
test expr-1.13 {TclCompileExprCmd: second level of substitutions in expr not in braces with single var reference} {
    set a xxx
    set x 27;  set bool {$x};  if $bool {set a foo}
    set a
} foo
test expr-1.14 {TclCompileExprCmd: second level of substitutions in expr with comparison as top-level operator} {
    set a xxx
    set x 2;  set b {$x};  set a [expr $b == 2]
    set a
} 1
test expr-1.15 {TclCompileExprCmd: second level of substitutions in expr with comparison as top-level operator} {
    set a xxx
    set x 2;  set b {$x};  set a [expr $b eq 2]
    set a
} 1

test expr-2.1 {TclCompileExpr: are builtin functions registered?} {
    expr double(5*[llength "6 2"])
} 10.0
test expr-2.2 {TclCompileExpr: error in expr} {
    catch {expr 2**3} msg
    set msg
} {syntax error in expression "2**3"}
test expr-2.3 {TclCompileExpr: junk after legal expr} {
    catch {expr 7*[llength "a b"]foo} msg
    set msg
} {syntax error in expression "7*2foo"}
test expr-2.4 {TclCompileExpr: numeric expr string rep == formatted int rep} {
    expr {0001}
} 1
test expr-2.5 {math functions} {
    expr {ceil(0.9)}
} 1.0
test expr-2.6 {math functions} {
    expr {floor(1.1)}
} 1.0
test expr-2.7 {math functions} {
    expr {floor  (1.1)}
} 1.0


test expr-3.1 {CompileCondExpr: just lor expr} {expr 3||0} 1
test expr-3.2 {CompileCondExpr: error in lor expr} {
    catch {expr x||3} msg
    set msg
} {syntax error in expression "x||3"} 
test expr-3.3 {CompileCondExpr: test true arm} {expr 3>2?44:66} 44
test expr-3.4 {CompileCondExpr: error compiling true arm} {
    catch {expr 3>2?2**3:66} msg
    set msg
} {syntax error in expression "3>2?2**3:66"}
test expr-3.5 {CompileCondExpr: test false arm} {expr 2>3?44:66} 66
test expr-3.6 {CompileCondExpr: error compiling false arm} {
    catch {expr 2>3?44:2**3} msg
    set msg
} {syntax error in expression "2>3?44:2**3"}
test expr-3.7 {CompileCondExpr: long arms & nested cond exprs} {unixOnly nonPortable} {
    puts "Note: doing test expr-3.7 which can take several minutes to run"
    hello_world
} {Hello world}
catch {unset xxx}
test expr-3.8 {CompileCondExpr: long arms & nested cond exprs} {unixOnly nonPortable} {
    puts "Note: doing test expr-3.8 which can take several minutes to run"
    do_twelve_days
} 2358
catch {unset xxx}

test expr-4.1 {CompileLorExpr: just land expr} {expr 1.3&&3.3} 1
test expr-4.2 {CompileLorExpr: error in land expr} {
    catch {expr x&&3} msg
    set msg
} {syntax error in expression "x&&3"} 
test expr-4.3 {CompileLorExpr: simple lor exprs} {expr 0||1.0} 1
test expr-4.4 {CompileLorExpr: simple lor exprs} {expr 3.0||0.0} 1
test expr-4.5 {CompileLorExpr: simple lor exprs} {expr 0||0||1} 1
test expr-4.6 {CompileLorExpr: error compiling lor arm} {
    catch {expr 2**3||4.0} msg
    set msg
} {syntax error in expression "2**3||4.0"}
test expr-4.7 {CompileLorExpr: error compiling lor arm} {
    catch {expr 1.3||2**3} msg
    set msg
} {syntax error in expression "1.3||2**3"}
test expr-4.8 {CompileLorExpr: error compiling lor arms} {
    list [catch {expr {"a"||"b"}} msg] $msg
} {1 {expected boolean value but got "a"}}
test expr-4.9 {CompileLorExpr: long lor arm} {
    set a "abcdefghijkl"
    set i 7
    expr {[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]] || [string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]] || [string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]] || [string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]}
} 1
test expr-4.10 {CompileLorExpr: error compiling ! operand} {
    list [catch {expr {!"a"}} msg] $msg
} {1 {can't use non-numeric string as operand of "!"}}
test expr-4.11 {CompileLorExpr: error compiling land arms} {
    list [catch {expr {"a"||0}} msg] $msg
} {1 {expected boolean value but got "a"}}
test expr-4.12 {CompileLorExpr: error compiling land arms} {
    list [catch {expr {0||"a"}} msg] $msg
} {1 {expected boolean value but got "a"}}


test expr-5.1 {CompileLandExpr: just bitor expr} {expr 7|0x13} 23
test expr-5.2 {CompileLandExpr: error in bitor expr} {
    catch {expr x|3} msg
    set msg
} {syntax error in expression "x|3"} 
test expr-5.3 {CompileLandExpr: simple land exprs} {expr 0&&1.0} 0
test expr-5.4 {CompileLandExpr: simple land exprs} {expr 0&&0} 0
test expr-5.5 {CompileLandExpr: simple land exprs} {expr 3.0&&1.2} 1
test expr-5.6 {CompileLandExpr: simple land exprs} {expr 1&&1&&2} 1
test expr-5.7 {CompileLandExpr: error compiling land arm} {
    catch {expr 2**3&&4.0} msg
    set msg
} {syntax error in expression "2**3&&4.0"}
test expr-5.8 {CompileLandExpr: error compiling land arm} {
    catch {expr 1.3&&2**3} msg
    set msg
} {syntax error in expression "1.3&&2**3"}
test expr-5.9 {CompileLandExpr: error compiling land arm} {
    list [catch {expr {"a"&&"b"}} msg] $msg
} {1 {expected boolean value but got "a"}}
test expr-5.10 {CompileLandExpr: long land arms} {
    set a "abcdefghijkl"
    set i 7
    expr {[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]] && [string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]] && [string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]] && [string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]^[string compare [format %c 103] [string index $a $i]]^[string compare [format %c 105] [string index $a $i]]}
} 1

test expr-6.1 {CompileBitXorExpr: just bitand expr} {expr 7&0x13} 3
test expr-6.2 {CompileBitXorExpr: error in bitand expr} {
    catch {expr x|3} msg
    set msg
} {syntax error in expression "x|3"} 
test expr-6.3 {CompileBitXorExpr: simple bitxor exprs} {expr 7^0x13} 20
test expr-6.4 {CompileBitXorExpr: simple bitxor exprs} {expr 3^0x10} 19
test expr-6.5 {CompileBitXorExpr: simple bitxor exprs} {expr 0^7} 7
test expr-6.6 {CompileBitXorExpr: simple bitxor exprs} {expr -1^7} -8
test expr-6.7 {CompileBitXorExpr: error compiling bitxor arm} {
    catch {expr 2**3|6} msg
    set msg
} {syntax error in expression "2**3|6"}
test expr-6.8 {CompileBitXorExpr: error compiling bitxor arm} {
    catch {expr 2^x} msg
    set msg
} {syntax error in expression "2^x"}
test expr-6.9 {CompileBitXorExpr: runtime error in bitxor arm} {
    list [catch {expr {24.0^3}} msg] $msg
} {1 {can't use floating-point value as operand of "^"}}
test expr-6.10 {CompileBitXorExpr: runtime error in bitxor arm} {
    list [catch {expr {"a"^"b"}} msg] $msg
} {1 {can't use non-numeric string as operand of "^"}}

test expr-7.1 {CompileBitAndExpr: just equality expr} {expr 3==2} 0
test expr-7.2 {CompileBitAndExpr: just equality expr} {expr 2.0==2} 1
test expr-7.3 {CompileBitAndExpr: just equality expr} {expr 3.2!=2.2} 1
test expr-7.4 {CompileBitAndExpr: just equality expr} {expr {"abc" == "abd"}} 0
test expr-7.5 {CompileBitAndExpr: error in equality expr} {
    catch {expr x==3} msg
    set msg
} {syntax error in expression "x==3"} 
test expr-7.6 {CompileBitAndExpr: simple bitand exprs} {expr 7&0x13} 3
test expr-7.7 {CompileBitAndExpr: simple bitand exprs} {expr 0xf2&0x53} 82
test expr-7.8 {CompileBitAndExpr: simple bitand exprs} {expr 3&6} 2
test expr-7.9 {CompileBitAndExpr: simple bitand exprs} {expr -1&-7} -7
test expr-7.10 {CompileBitAndExpr: error compiling bitand arm} {
    catch {expr 2**3&6} msg
    set msg
} {syntax error in expression "2**3&6"}
test expr-7.11 {CompileBitAndExpr: error compiling bitand arm} {
    catch {expr 2&x} msg
    set msg
} {syntax error in expression "2&x"}
test expr-7.12 {CompileBitAndExpr: runtime error in bitand arm} {
    list [catch {expr {24.0&3}} msg] $msg
} {1 {can't use floating-point value as operand of "&"}}
test expr-7.13 {CompileBitAndExpr: runtime error in bitand arm} {
    list [catch {expr {"a"&"b"}} msg] $msg
} {1 {can't use non-numeric string as operand of "&"}}
test expr-7.14 {CompileBitAndExpr: equality expr} {expr 3eq2} 0
test expr-7.18 {CompileBitAndExpr: equality expr} {expr {"abc" eq "abd"}} 0
test expr-7.20 {CompileBitAndExpr: error in equality expr} {
    catch {expr xne3} msg
   set msg
} {syntax error in expression "xne3"}
test expr-7.21 {CompileBitAndExpr: equality expr} {
    expr {"7.91e+16" eq 7.91e+016}
} 0
test expr-7.22 {CompileBitAndExpr: equality expr} {
    expr {"7.91e+016" eq 7.91e+016}
} 1
test expr-7.23 {CompileBitAndExpr: equality expr} {
    # This test could fail if the string rep generated
    # for the parsed expr value is not the same as
    # the string rep of the value variable. Uncommenting
    # the puts statement that prints the parsed variable
    # hides the bug since a string rep is generated
    # before entering the expr module.
    set value "7.91e+016"
    set parsed [expr {7.91e+016}]
    #puts "value  is \"$value\""
    #puts "parsed is \"$parsed\""
    expr {$parsed eq $value}
} 1
proc test_expr_eq { value } {
    set parsed [expr {$value}]
    # puts "parsed is \"$parsed\""
    expr {$parsed eq $value}
}
test expr-7.24 {CompileBitAndExpr: equality expr} {
    test_expr_eq "7.91e+016"
} 1


test expr-8.1 {CompileEqualityExpr: just relational expr} {expr 3>=2} 1
test expr-8.2 {CompileEqualityExpr: just relational expr} {expr 2<=2.1} 1
test expr-8.3 {CompileEqualityExpr: just relational expr} {expr 3.2>"2.2"} 1
test expr-8.4 {CompileEqualityExpr: just relational expr} {expr {"0y"<"0x12"}} 0
test expr-8.5 {CompileEqualityExpr: error in relational expr} {
    catch {expr x>3} msg
    set msg
} {syntax error in expression "x>3"} 
test expr-8.6 {CompileEqualityExpr: simple equality exprs} {expr 7==0x13} 0
test expr-8.7 {CompileEqualityExpr: simple equality exprs} {expr -0xf2!=0x53} 1

test expr-8.8 {CompileEqualityExpr: simple equality exprs} {
    expr {"12398712938788234-1298379" != ""}
} 1
test expr-8.8.1 {CompileEqualityExpr: simple equality exprs} {
    set x 12398712938788234
    expr {$x == 100}
} 0
test expr-8.8.2 {CompileEqualityExpr: simple equality exprs} {
    expr {"0x12 " == "0x12"}
} 1
test expr-8.8.3 {CompileEqualityExpr: simple equality exprs} {
    expr {"0x12 " eq "0x12"}
} 0
test expr-8.8.4 {CompileEqualityExpr: simple equality exprs} {
    expr {"1.0e100000000" == "0.0"}
} 0
test expr-8.8.5 {CompileEqualityExpr: just relational expr} {
    expr {"0y" == "0x0"}
} 0
test expr-8.8.6 {CompileEqualityExpr: just relational expr} {
    # Compare original strings from variables.
    set v1 "0y"
    set v2 "0x12"
    expr {$v1 < $v2}
} 0
test expr-8.8.7 {CompileEqualityExpr: simple equality exprs} {
    expr {"fake" != "bob"}
} 1

test expr-8.9 {CompileEqualityExpr: simple equality exprs} {expr -1!="abc"} 1
test expr-8.10 {CompileEqualityExpr: error compiling equality arm} {
    catch {expr 2**3==6} msg
    set msg
} {syntax error in expression "2**3==6"}
test expr-8.11 {CompileEqualityExpr: error compiling equality arm} {
    catch {expr 2!=x} msg
    set msg
} {syntax error in expression "2!=x"}
test expr-8.12 {CompileBitAndExpr: equality expr} {expr {"a"eq"a"}} 1
test expr-8.13 {CompileBitAndExpr: equality expr} {expr {"\374" eq "ü"}} 1
test expr-8.14 {CompileBitAndExpr: equality expr} {expr 3eq2} 0
test expr-8.15 {CompileBitAndExpr: equality expr} {expr 2.0eq2} 0
test expr-8.16 {CompileBitAndExpr: equality expr} {expr 3.2ne2.2} 1
test expr-8.17 {CompileBitAndExpr: equality expr} {expr 01eq1} 0
test expr-8.18 {CompileBitAndExpr: equality expr} {expr {"abc" eq "abd"}} 0
test expr-8.19 {CompileBitAndExpr: equality expr} {expr {"abc" ne "abd"}} 1
test expr-8.20 {CompileBitAndExpr: error in equality expr} {
    catch {expr x ne3} msg
    set msg
} {syntax error in expression "x ne3"} 
test expr-8.21 {CompileBitAndExpr: error in equality expr} {
    # These should be ""ed to avoid the error
    catch {expr a eq b} msg
    set msg
} {syntax error in expression "a eq b"}
test expr-8.22 {CompileBitAndExpr: equality expr} {expr 3==2} 0
test expr-8.23 {expr edge cases} {
    list [catch {expr {1e}} err] $err
} {1 {syntax error in expression "1e"}}
test expr-8.24 {expr edge cases} {
    list [catch {expr {1E}} err] $err
} {1 {syntax error in expression "1E"}}
test expr-8.25 {expr edge cases} {
    list [catch {expr {1e+}} err] $err
} {1 {syntax error in expression "1e+"}}
test expr-8.26 {expr edge cases} {
    list [catch {expr {1E+}} err] $err
} {1 {syntax error in expression "1E+"}}
test expr-8.27 {expr edge cases} {
    list [catch {expr {1ea}} err] $err
} {1 {syntax error in expression "1ea"}}


test expr-9.1 {CompileRelationalExpr: just shift expr} {expr 3<<2} 12
test expr-9.2 {CompileRelationalExpr: just shift expr} {expr 0xff>>2} 63
test expr-9.3 {CompileRelationalExpr: just shift expr} {expr -1>>2} -1
test expr-9.4 {CompileRelationalExpr: just shift expr} {expr {1<<3}} 8
test expr-9.5 {CompileRelationalExpr: just shift expr} {
    list [catch {expr {""<<1}} err] $err
} {1 {can't use empty string as operand of "<<"}}
test expr-9.6 {CompileRelationalExpr: just shift expr} {
    list [catch {expr {1<<""}} err] $err
} {1 {can't use empty string as operand of "<<"}}

# The following test is different for 32-bit versus 64-bit
# architectures because LONG_MIN is different

if {0x80000000 > 0} {
    test expr-9.5 {CompileRelationalExpr: shift expr producing LONG_MIN} {nonPortable} {
	expr {1<<63}
    } -9223372036854775808
} else {
    test expr-9.5 {CompileRelationalExpr: shift expr producing LONG_MIN} {nonPortable} {
	expr {1<<31}
    } -2147483648
}
test expr-9.6 {CompileRelationalExpr: error in shift expr} {
    catch {expr x>>3} msg
    set msg
} {syntax error in expression "x>>3"} 
test expr-9.7 {CompileRelationalExpr: simple relational exprs} {expr 0xff>=+0x3} 1
test expr-9.8 {CompileRelationalExpr: simple relational exprs} {expr -0xf2<0x3} 1
test expr-9.9 {CompileRelationalExpr: error compiling relational arm} {
    catch {expr 2**3>6} msg
    set msg
} {syntax error in expression "2**3>6"}
test expr-9.10 {CompileRelationalExpr: error compiling relational arm} {
    catch {expr 2<x} msg
    set msg
} {syntax error in expression "2<x"}

test expr-10.1 {CompileShiftExpr: just add expr} {expr 4+-2} 2
test expr-10.2 {CompileShiftExpr: just add expr} {expr 0xff-2} 253
test expr-10.3 {CompileShiftExpr: just add expr} {expr -1--2} 1
test expr-10.4 {CompileShiftExpr: just add expr} {expr 1-0123} -82
test expr-10.5 {CompileShiftExpr: error in add expr} {
    catch {expr x+3} msg
    set msg
} {syntax error in expression "x+3"}
test expr-10.6 {CompileShiftExpr: simple shift exprs} {expr 0xff>>0x3} 31
test expr-10.7 {CompileShiftExpr: simple shift exprs} {expr -0xf2<<0x3} -1936
test expr-10.8 {CompileShiftExpr: error compiling shift arm} {
    catch {expr 2**3>>6} msg
    set msg
} {syntax error in expression "2**3>>6"}
test expr-10.9 {CompileShiftExpr: error compiling shift arm} {
    catch {expr 2<<x} msg
    set msg
} {syntax error in expression "2<<x"}
test expr-10.10 {CompileShiftExpr: runtime error} {
    list [catch {expr {24.0>>43}} msg] $msg
} {1 {can't use floating-point value as operand of ">>"}}
test expr-10.11 {CompileShiftExpr: runtime error} {
    list [catch {expr {"a"<<"b"}} msg] $msg
} {1 {can't use non-numeric string as operand of "<<"}}
test expr-10.12 {CompileAddExpr: no value2 in subexpr} {
    list [catch {expr {(1 + ) + 3}} err] $err
} {1 {syntax error in expression "(1 + ) + 3"}}

test expr-11.1 {CompileAddExpr: just multiply expr} {expr 4*-2} -8
test expr-11.2 {CompileAddExpr: just multiply expr} {expr 0xff%2} 1
test expr-11.3 {CompileAddExpr: just multiply expr} {expr -1/2} -1
test expr-11.4 {CompileAddExpr: just multiply expr} {expr 7891%0123} 6
test expr-11.5 {CompileAddExpr: error in multiply expr} {
    catch {expr x*3} msg
    set msg
} {syntax error in expression "x*3"}
test expr-11.6 {CompileAddExpr: simple add exprs} {expr 0xff++0x3} 258
test expr-11.7 {CompileAddExpr: simple add exprs} {expr -0xf2--0x3} -239
test expr-11.8 {CompileAddExpr: error compiling add arm} {
    catch {expr 2**3+6} msg
    set msg
} {syntax error in expression "2**3+6"}
test expr-11.9 {CompileAddExpr: error compiling add arm} {
    catch {expr 2-x} msg
    set msg
} {syntax error in expression "2-x"}
test expr-11.10 {CompileAddExpr: runtime error} {
    list [catch {expr {24.0+"xx"}} msg] $msg
} {1 {can't use non-numeric string as operand of "+"}}
test expr-11.11 {CompileAddExpr: runtime error} {
    list [catch {expr {"xx"+24.0}} msg] $msg
} {1 {can't use non-numeric string as operand of "+"}}
test expr-11.12 {CompileAddExpr: runtime error} {
    list [catch {expr {true+24.0}} msg] $msg
} {1 {can't use non-numeric string as operand of "+"}}
test expr-11.13 {CompileAddExpr: runtime error} {
    list [catch {expr {24.0+true}} msg] $msg
} {1 {can't use non-numeric string as operand of "+"}}
test expr-11.14 {CompileAddExpr: runtime error} {
    list [catch {expr {"a"-"b"}} msg] $msg
} {1 {can't use non-numeric string as operand of "-"}}
test expr-11.15 {CompileAddExpr: runtime error} {
    list [catch {expr {3/0}} msg] $msg
} {1 {divide by zero}}
test expr-11.16 {CompileAddExpr: runtime error} {
    list [catch {expr {2.3/0.0}} msg] $msg
} {1 {divide by zero}}

test expr-12.1 {CompileMultiplyExpr: just unary expr} {expr ~4} -5
test expr-12.2 {CompileMultiplyExpr: just unary expr} {expr --5} 5
test expr-12.3 {CompileMultiplyExpr: just unary expr} {expr !27} 0
test expr-12.4 {CompileMultiplyExpr: just unary expr} {expr ~0xff00ff} -16711936
test expr-12.5 {CompileMultiplyExpr: error in unary expr} {
    catch {expr ~x} msg
    set msg
} {syntax error in expression "~x"}
test expr-12.6 {CompileMultiplyExpr: simple multiply exprs} {expr 0xff*0x3} 765
test expr-12.7 {CompileMultiplyExpr: simple multiply exprs} {expr -0xf2%-0x3} -2
test expr-12.8 {CompileMultiplyExpr: error compiling multiply arm} {
    catch {expr 2*3%%6} msg
    set msg
} {syntax error in expression "2*3%%6"}
test expr-12.9 {CompileMultiplyExpr: error compiling multiply arm} {
    catch {expr 2*x} msg
    set msg
} {syntax error in expression "2*x"}
test expr-12.10 {CompileMultiplyExpr: runtime error} {
    list [catch {expr {24.0*"xx"}} msg] $msg
} {1 {can't use non-numeric string as operand of "*"}}
test expr-12.11 {CompileMultiplyExpr: runtime error} {
    list [catch {expr {"a"/"b"}} msg] $msg
} {1 {can't use non-numeric string as operand of "/"}}

test expr-13.1 {CompileUnaryExpr: unary exprs} {expr -0xff} -255
test expr-13.2 {CompileUnaryExpr: unary exprs} {expr +000123} 83
test expr-13.3 {CompileUnaryExpr: unary exprs} {expr +--++36} 36
test expr-13.4 {CompileUnaryExpr: unary exprs} {expr !2} 0
test expr-13.5 {CompileUnaryExpr: unary exprs} {expr +--+-62.0} -62.0
test expr-13.6 {CompileUnaryExpr: unary exprs} {expr !0.0} 1
test expr-13.7 {CompileUnaryExpr: unary exprs} {expr !0xef} 0
test expr-13.8 {CompileUnaryExpr: error compiling unary expr} {
    catch {expr ~x} msg
    set msg
} {syntax error in expression "~x"}
test expr-13.9 {CompileUnaryExpr: error compiling unary expr} {
    catch {expr !1.x} msg
    set msg
} {syntax error in expression "!1.x"}
test expr-13.10 {CompileUnaryExpr: runtime error} {
    list [catch {expr {~"xx"}} msg] $msg
} {1 {can't use non-numeric string as operand of "~"}}
test expr-13.11 {CompileUnaryExpr: runtime error} {
    list [catch {expr ~4.0} msg] $msg
} {1 {can't use floating-point value as operand of "~"}}
test expr-13.12 {CompileUnaryExpr: just primary expr} {expr 0x123} 291
test expr-13.13 {CompileUnaryExpr: just primary expr} {
    set a 27
    expr $a
} 27
test expr-13.14 {CompileUnaryExpr: just primary expr} {
    expr double(27)
} 27.0
test expr-13.15 {CompileUnaryExpr: just primary expr} {expr "123"} 123
test expr-13.16 {CompileUnaryExpr: error in primary expr} {
    catch {expr [set]} msg
    set msg
} {wrong # args: should be "set varName ?newValue?"}
test expr-13.17 {CompileUnaryExpr: negating non-numeric boolean literals} {
    set a1 yes; set a0 no; set b1 true; set b0 false
    list [expr {!$a1}] [expr {!$a0}] [expr {!$b1}] [expr {!$b0}]
} {0 1 0 1}
test expr-13.18 {CompileUnaryExpr: just primary expr} {
    expr {"040"}
} 32
test expr-13.19 {CompileUnaryExpr: just primary expr} {
    set v 040
    # Note that format parses "040" as a double and
    # the double number parse ignores leading zeros.
    # The expr module should parse this string as
    # an integer even if the interal rep is a double.
    list [expr {$v}] [format %0.2f $v] [expr {$v}]
} {32 40.00 32}

test expr-14.1 {CompilePrimaryExpr: literal primary} {expr 1} 1
test expr-14.2 {CompilePrimaryExpr: literal primary} {expr 123} 123
test expr-14.3 {CompilePrimaryExpr: literal primary} {expr 0xff} 255
test expr-14.4 {CompilePrimaryExpr: literal primary} {expr 00010} 8
test expr-14.5 {CompilePrimaryExpr: literal primary} {expr 62.0} 62.0
test expr-14.6.0 {CompilePrimaryExpr: literal primary} {
    expr 3.1400000
} 3.14
test expr-14.6.1 {CompilePrimaryExpr: literal primary} {
    list \
        [expr {1e16}] \
        [expr {1e+16}] \
        [expr {1.000e16}] \
        [expr {1.0e+016}]
} {1e+016 1e+016 1e+016 1e+016}
test expr-14.6.2 {CompilePrimaryExpr: literal primary} {
    list \
        [expr {7.91e16}] \
        [expr {7.91e+16}] \
        [expr {7.91e016}] \
        [expr {7.91e+016}] \
        [expr {7.91e+116}]
} {7.91e+016 7.91e+016 7.91e+016 7.91e+016 7.91e+116}

test expr-14.7 {CompilePrimaryExpr: literal primary} {expr {{abcde}<{abcdef}}} 1
test expr-14.8 {CompilePrimaryExpr: literal primary} {expr {{abc\
def} < {abcdef}}} 1
test expr-14.9 {CompilePrimaryExpr: literal primary} {expr {{abc\tde} > {abc\tdef}}} 0
test expr-14.10 {CompilePrimaryExpr: literal primary} {expr {{123}}} 123
test expr-14.11 {CompilePrimaryExpr: var reference primary} {
    set i 789
    list [expr {$i}] [expr $i]
} {789 789}
test expr-14.12 {CompilePrimaryExpr: var reference primary} {
    set i {789}    ;# test expr's aggressive conversion to numeric semantics
    list [expr {$i}] [expr $i]
} {789 789}
test expr-14.13 {CompilePrimaryExpr: var reference primary} {
    catch {unset a}
    set a(foo) foo
    set a(bar) bar
    set a(123) 123
    set result ""
    lappend result [expr $a(123)] [expr {$a(bar)<$a(foo)}]
    catch {unset a}
    set result
} {123 1}
test expr-14.14 {CompilePrimaryExpr: var reference primary} {
    set i 123    ;# test "$var.0" floating point conversion hack
    list [expr $i] [expr $i.0] [expr $i.0/12.0]
} {123 123.0 10.25}
test expr-14.15 {CompilePrimaryExpr: var reference primary} {
    set i 123
    catch {expr $i.2} msg
    set msg
} 123.2
test expr-14.16 {CompilePrimaryExpr: error compiling var reference primary} {
    catch {expr {$a(foo}} msg
    set errorInfo
} {missing )
    while executing
"expr {$a(foo}"}
test expr-14.17 {CompilePrimaryExpr: string primary that looks like var ref} {
    expr $
} $
test expr-14.18 {CompilePrimaryExpr: quoted string primary} {
    expr "21"
} 21
test expr-14.19 {CompilePrimaryExpr: quoted string primary} {
    set i 123
    set x 456
    expr "$i+$x"
} 579
test expr-14.20 {CompilePrimaryExpr: quoted string primary} {
    set i 3
    set x 6
    expr 2+"$i.$x"
} 5.6
test expr-14.21 {CompilePrimaryExpr: error in quoted string primary} {
    catch {expr "[set]"} msg
    set msg
} {wrong # args: should be "set varName ?newValue?"}
test expr-14.22 {CompilePrimaryExpr: subcommand primary} {
    expr {[set i 123; set i]}
} 123
test expr-14.23 {CompilePrimaryExpr: error in subcommand primary} {
    catch {expr {[set]}} msg
    set errorInfo
} {wrong # args: should be "set varName ?newValue?"
    while executing
"set"
    invoked from within
"expr {[set]}"}
test expr-14.24 {CompilePrimaryExpr: error in subcommand primary} {
    catch {expr {[set i}} msg
    set errorInfo
} {missing close-bracket
    while executing
"expr {[set i}"}
test expr-14.25 {CompilePrimaryExpr: math function primary} {
    format %.6g [expr exp(1.0)]
} 2.71828
test expr-14.26 {CompilePrimaryExpr: math function primary} {
    format %.6g [expr pow(2.0+0.1,3.0+0.1)]
} 9.97424
test expr-14.27 {CompilePrimaryExpr: error in math function primary} {
    catch {expr sinh::(2.0)} msg
    set errorInfo
} {syntax error in expression "sinh::(2.0)"
    while executing
"expr sinh::(2.0)"}
test expr-14.28 {CompilePrimaryExpr: subexpression primary} {
    expr 2+(3*4)
} 14
test expr-14.29 {CompilePrimaryExpr: error in subexpression primary} {
    catch {expr 2+(3*[set])} msg
    set errorInfo
} {wrong # args: should be "set varName ?newValue?"
    while executing
"set"
    invoked from within
"expr 2+(3*[set])"}
test expr-14.30 {CompilePrimaryExpr: missing paren in subexpression primary} {
    catch {expr 2+(3*(4+5)} msg
    set errorInfo
} {syntax error in expression "2+(3*(4+5)"
    while executing
"expr 2+(3*(4+5)"}
test expr-14.31 {CompilePrimaryExpr: just var ref in subexpression primary} {
    set i "5+10"
    list "[expr $i] == 15" "[expr ($i)] == 15" "[eval expr ($i)] == 15"
} {{15 == 15} {15 == 15} {15 == 15}}
test expr-14.32 {CompilePrimaryExpr: unexpected token} {
    catch {expr @} msg
    set errorInfo
} {syntax error in expression "@"
    while executing
"expr @"}

test expr-15.1 {CompileMathFuncCall: missing parenthesis} {
    catch {expr sinh2.0)} msg
    set errorInfo
} {syntax error in expression "sinh2.0)"
    while executing
"expr sinh2.0)"}
test expr-15.2 {CompileMathFuncCall: unknown math function} {
    catch {expr whazzathuh(1)} msg
    set errorInfo
} {unknown math function "whazzathuh"
    while executing
"expr whazzathuh(1)"}
test expr-15.3 {CompileMathFuncCall: too many arguments} {
    catch {expr sin(1,2,3)} msg
    set errorInfo
} {too many arguments for math function
    while executing
"expr sin(1,2,3)"}
test expr-15.4 {CompileMathFuncCall: ')' found before last required arg} {
    catch {expr sin()} msg
    set errorInfo
} {too few arguments for math function
    while executing
"expr sin()"}
test expr-15.5 {CompileMathFuncCall: too few arguments} {
    catch {expr pow(1)} msg
    set errorInfo
} {too few arguments for math function
    while executing
"expr pow(1)"}
test expr-15.6 {CompileMathFuncCall: missing ')'} {
    catch {expr sin(1} msg
    set errorInfo
} {syntax error in expression "sin(1"
    while executing
"expr sin(1"}

test expr-15.7 {CompileMathFuncCall: call registered math function} {registeredMathFuncs} {
    expr 2*T1()
} 246
test expr-15.8 {CompileMathFuncCall: call registered math function} {registeredMathFuncs} {
    expr T2()*3
} 1035
test expr-15.9 {CompileMathFuncCall: call registered math function} {registeredMathFuncs} {
    expr T3(21, 37)
} 37
test expr-15.10 {CompileMathFuncCall: call registered math function} {registeredMathFuncs} {
    expr T3(21.2, 37)
} 37.0
test expr-15.11 {CompileMathFuncCall: call registered math function} {registeredMathFuncs} {
    expr T3(-21.2, -17.5)
} -17.5
test expr-15.12 {ExprCallMathFunc: call registered math function} {registeredMathFuncs wideMathFunc} {
    expr T3(21, wide(37))
} 37
test expr=15.13 {ExprCallMathFunc: call registered math function} {registeredMathFuncs wideMathFunc} {
    expr T3(wide(21), 37)
} 37
test expr=15.14 {ExprCallMathFunc: call registered math function} {registeredMathFuncs wideMathFunc} {
    expr T3(wide(21), wide(37))
} 37
test expr-15.15 {ExprCallMathFunc: call registered math function} {registeredMathFuncs wideMathFunc} {
    expr T3(21.0, wide(37))
} 37.0
test expr=15.16 {ExprCallMathFunc: call registered math function} {registeredMathFuncs wideMathFunc} {
    expr T3(wide(21), 37.0)
} 37.0

test expr-16.1 {GetToken: checks whether integer token starting with "0x" (e.g., "0x$") is invalid} {
    catch {unset a}
    set a(VALUE) ff15
    set i 123
    if {[expr 0x$a(VALUE)] & 16} {
        set i {}
    }
    set i
} {}
test expr-16.2 {GetToken: check for string literal in braces} {
    expr {{1}}
} {1}

# Check "expr" and computed command names.

test expr-17.1 {expr and computed command names} {
    set i 0
    set z expr
    $z 1+2
} 3

# Check correct conversion of operands to numbers: If the string looks like
# an integer, convert to integer. Otherwise, if the string looks like a
# double, convert to double.

test expr-18.1 {expr and conversion of operands to numbers} {
    set x [lindex 11 0]
    catch {expr int($x)}
    expr {$x}
} 11
test expr-18.2 {whitespace strings should not be == 0 (buggy strtod)} {
    expr {" "}
} { }

# Check "expr" and interpreter result object resetting before appending
# an error msg during evaluation of exprs not in {}s

test expr-19.1 {expr and interpreter result object resetting} {
    proc p {} {
        set t  10.0
        set x  2.0
        set dx 0.2
        set f  {$dx-$x/10}
        set g  {-$x/5}
        set center 1.0
        set x  [expr $x-$center]
        set dx [expr $dx+$g]
        set x  [expr $x+$f+$center]
        set x  [expr $x+$f+$center]
        set y  [expr round($x)]
    }
    p
} 3

# Test for incorrect "double evaluation" semantics

test expr-20.1 {wrong brace matching} {
    catch {unset l}
    catch {unset r}
    catch {unset q}
    catch {unset cmd}
    catch {unset a}
    set l "\{"; set r "\}"; set q "\""
    set cmd "expr $l$q|$q == $q$r$q$r"
    list [catch $cmd a] $a
} {1 {extra characters after close-brace}}
test expr-20.2 {double invocation of variable traces} {
    set exprtracecounter 0
    proc exprtraceproc {args} {
       upvar #0 exprtracecounter counter
       set argc [llength $args]
       set extraargs [lrange $args 0 [expr {$argc - 4}]]
       set name [lindex $args [expr {$argc - 3}]]
       upvar 1 $name var
       if {[incr counter] % 2 == 1} {
           set var "$counter oops [concat $extraargs]"
       } else {
           set var "$counter + [concat $extraargs]"
       }
    }
    trace variable exprtracevar r [list exprtraceproc 10]
    list [catch {expr "$exprtracevar + 20"} a] $a \
        [catch {expr "$exprtracevar + 20"} b] $b \
        [unset exprtracevar exprtracecounter]
} {1 {syntax error in expression "1 oops 10 + 20"} 0 32 {}}
test expr-20.3 {broken substitution of integer digits} {
    # fails with 8.0.x, but not 8.1b2
    list [set a 000; expr 0x1$a] [set a 1; expr ${a}000]
} {4096 1000}
test expr-20.4 {proper double evaluation compilation, error case} {
    catch {unset a}; # make sure $a doesn't exist
    list [catch {expr 1?{$a}:0} msg] $msg
} {1 {can't read "a": no such variable}}
test expr-20.5 {proper double evaluation compilation, working case} {
    set a yellow
    expr 1?{$a}:0
} yellow
test expr-20.6 {handling of compile error in trial compile} {
    list [catch {expr + {[incr]}} msg] $msg
} {1 {wrong # args: should be "incr varName ?increment?"}}
test expr-20.7 {handling of compile error in runtime case} {
    list [catch {expr + {[error foo]}} msg] $msg
} {1 foo}

# Test for non-numeric boolean literal handling
test expr-21.1 	{non-numeric boolean literals} {expr false } false
test expr-21.2 	{non-numeric boolean literals} {expr true  } true
test expr-21.3 	{non-numeric boolean literals} {expr off   } off
test expr-21.4 	{non-numeric boolean literals} {expr on    } on
test expr-21.5 	{non-numeric boolean literals} {expr no    } no
test expr-21.6 	{non-numeric boolean literals} {expr yes   } yes
test expr-21.7 	{non-numeric boolean literals} {expr !false} 1
test expr-21.8 	{non-numeric boolean literals} {expr !true } 0
test expr-21.9 	{non-numeric boolean literals} {expr !off  } 1
test expr-21.10 {non-numeric boolean literals} {expr !on   } 0
test expr-21.11 {non-numeric boolean literals} {expr !no   } 1
test expr-21.12 {non-numeric boolean literals} {expr !yes  } 0
test expr-21.13 {non-numeric boolean literals} {
    list [catch {expr !truef} err] $err
} {1 {syntax error in expression "!truef"}}
test expr-21.14 {non-numeric boolean literals} {
    list [catch {expr !"truef"} err] $err
} {1 {can't use non-numeric string as operand of "!"}}
test expr-21.15 {non-numeric boolean variables} {
    set v truef
    list [catch {expr {!$v}} err] $err
} {1 {can't use non-numeric string as operand of "!"}}
test expr-21.16 {non-numeric boolean variables} {
    set v "true "
    list [catch {expr {!$v}} err] $err
} {1 {can't use non-numeric string as operand of "!"}}
test expr-21.17 {non-numeric boolean variables} {
    set v "tru"
    list [catch {expr {!$v}} err] $err
} {0 0}
test expr-21.18 {non-numeric boolean variables} {
    set v "fal"
    list [catch {expr {!$v}} err] $err
} {0 1}
test expr-21.19 {non-numeric boolean variables} {
    set v "y"
    list [catch {expr {!$v}} err] $err
} {0 0}
test expr-21.20 {non-numeric boolean variables} {
    set v "of"
    list [catch {expr {!$v}} err] $err
} {0 1}
test expr-21.21 {non-numeric boolean variables} {
    set v "o"
    list [catch {expr {!$v}} err] $err
} {1 {can't use non-numeric string as operand of "!"}}
test expr-21.22 {non-numeric boolean variables} {
    set v ""
    list [catch {expr {!$v}} err] $err
} {1 {can't use empty string as operand of "!"}}

# Test for non-numeric float handling.
#
# These are non-portable because strtod()-support for "Inf" and "NaN"
# is so wildly variable.  This sucks...
test expr-22.1 {non-numeric floats} nonPortable {
    list [catch {expr {NaN + 1}} msg] $msg
} {1 {can't use non-numeric floating-point value as operand of "+"}}
test expr-22.2 {non-numeric floats} nonPortable {
    list [catch {expr {Inf + 1}} msg] $msg
} {1 {can't use infinite floating-point value as operand of "+"}}
test expr-22.3 {non-numeric floats} nonPortable {
    set nan NaN
    list [catch {expr {$nan + 1}} msg] $msg
} {1 {can't use non-numeric floating-point value as operand of "+"}}
test expr-22.4 {non-numeric floats} nonPortable {
    set inf Inf
    list [catch {expr {$inf + 1}} msg] $msg
} {1 {can't use infinite floating-point value as operand of "+"}}
test expr-22.5 {non-numeric floats} nonPortable {
    list [catch {expr NaN} msg] $msg
} {1 {domain error: argument not in valid range}}
test expr-22.6 {non-numeric floats} nonPortable {
    list [catch {expr Inf} msg] $msg
} {1 {floating-point value too large to represent}}
test expr-22.7 {non-numeric floats} nonPortable {
    list [catch {expr {1 / NaN}} msg] $msg
} {1 {can't use non-numeric floating-point value as operand of "/"}}
test expr-22.8 {non-numeric floats} nonPortable {
    list [catch {expr {1 / Inf}} msg] $msg
} {1 {can't use infinite floating-point value as operand of "/"}}
# Make sure [Bug 761471] stays fixed.
test expr-22.9 {non-numeric floats: shared object equality and NaN} {unimplemented} {
    set x NaN
    expr {$x == $x}
} 0

# Some compilers get this wrong; ensure that we work around it correctly
test expr-24.1 {expr edge cases; shifting} {expr int(5)>>31} 0
test expr-24.2 {expr edge cases; shifting} {expr int(5)>>63} 0
test expr-24.3 {expr edge cases; shifting} {wideMathFunc} {expr wide(5)>>31} 0
test expr-24.4 {expr edge cases; shifting} {wideMathFunc} {expr wide(5)>>63} 0
test expr-24.5 {expr edge cases; shifting} {nonPortable} {expr int(5)<<31} 0
test expr-24.6 {expr edge cases; shifting} {nonPortable} {expr int(5)<<63} 0
test expr-24.7 {expr edge cases; shifting} {wideMathFunc} {expr wide(5)<<31} 10737418240
test expr-24.8 {expr edge cases; shifting} {nonPortable wideMathFunc} {expr wide(5)<<63} -9223372036854775808
test expr-24.9 {expr edge cases; shifting} {expr 5>>32} 0

# The following series starts as 32 so that the numbers
# match those found in Tcl 8.5.

test expr-32.1 {expr mod basics} {
    set mod_nums [list \
        {-3 1} {-3 2} {-3 3} {-3 4} {-3 5} \
        {-3 -1} {-3 -2} {-3 -3} {-3 -4} {-3 -5} \
        {-2 1} {-2 2} {-2 3} {-2 4} {-2 5} \
        {-2 -1} {-2 -2} {-2 -3} {-2 -4} {-2 -5} \
        {-1 1} {-1 2} {-1 3} {-1 4} {-1 5} \
        {-1 -1} {-1 -2} {-1 -3} {-1 -4} {-1 -5} \
        {0 -100} {0 -1} {0 1} {0 100} \
        {1 1} {1 2} {1 3} {1 4} {1 5} \
        {1 -1} {1 -2} {1 -3} {1 -4} {1 -5} \
        {2 1} {2 2} {2 3} {2 4} {2 5} \
        {2 -1} {2 -2} {2 -3} {2 -4} {2 -5} \
        {3 1} {3 2} {3 3} {3 4} {3 5} \
        {3 -1} {3 -2} {3 -3} {3 -4} {3 -5} \
        ]
    set results [list]
    foreach pair $mod_nums {
        set dividend [lindex $pair 0]
        set divisor [lindex $pair 1]
        lappend results [expr {$dividend % $divisor}]
    }
    set results
} [list \
    0 1 0 1 2 \
    0 -1 0 -3 -3 \
    0 0 1 2 3 \
    0 0 -2 -2 -2 \
    0 1 2 3 4 \
    0 -1 -1 -1 -1 \
    0 0 0 0 \
    0 1 1 1 1 \
    0 -1 -2 -3 -4 \
    0 0 2 2 2 \
    0 0 -1 -2 -3 \
    0 1 0 3 3 \
    0 -1 0 -1 -2 \
    ]
        
test expr-32.2 {expr div basics} {
    set div_nums [list \
        {-3 1} {-3 2} {-3 3} {-3 4} {-3 5} \
        {-3 -1} {-3 -2} {-3 -3} {-3 -4} {-3 -5} \
        {-2 1} {-2 2} {-2 3} {-2 4} {-2 5} \
        {-2 -1} {-2 -2} {-2 -3} {-2 -4} {-2 -5} \
        {-1 1} {-1 2} {-1 3} {-1 4} {-1 5} \
        {-1 -1} {-1 -2} {-1 -3} {-1 -4} {-1 -5} \
        {0 -100} {0 -1} {0 1} {0 100} \
        {1 1} {1 2} {1 3} {1 4} {1 5} \
        {1 -1} {1 -2} {1 -3} {1 -4} {1 -5} \
        {2 1} {2 2} {2 3} {2 4} {2 5} \
        {2 -1} {2 -2} {2 -3} {2 -4} {2 -5} \
        {3 1} {3 2} {3 3} {3 4} {3 5} \
        {3 -1} {3 -2} {3 -3} {3 -4} {3 -5} \
        ]
    set results [list]
    foreach pair $div_nums {
        set dividend [lindex $pair 0]
        set divisor [lindex $pair 1]
        lappend results [expr {$dividend / $divisor}]
    }
    set results
} [list \
    -3 -2 -1 -1 -1 \
    3 1 1 0 0 \
    -2 -1 -1 -1 -1 \
    2 1 0 0 0 \
    -1 -1 -1 -1 -1 \
    1 0 0 0 0 \
    0 0 0 0 \
    1 0 0 0 0 \
    -1 -1 -1 -1 -1 \
    2 1 0 0 0 \
    -2 -1 -1 -1 -1 \
    3 1 1 0 0 \
    -3 -2 -1 -1 -1 \
    ]

test expr-33.1 {parse largest long value} {longis32bit} {
    set max_long_str 2147483647
    set max_long_hex "0x7FFFFFFF "

    # Convert to integer (long, not wide) internal rep
    set max_long 2147483647
    string is integer $max_long

    list \
        [expr {" $max_long_str "}] \
        [expr {$max_long_str + 0}] \
        [expr {$max_long + 0}] \
        [expr {2147483647 + 0}] \
        [expr {$max_long == $max_long_hex}] \
        [expr {(2147483647 + 1) < 0}] \

} {2147483647 2147483647 2147483647 2147483647 1 1}

test expr-33.2 {parse smallest long value} {longis32bit} {
    set min_long_str -2147483648
    set min_long_hex "-0x80000000 "

    set min_long -2147483648
    # This will convert to integer (not wide) internal rep
    string is integer $min_long

    # Note: If the final expression returns 0 then the
    # expression literal is being promoted to a wide type
    # when it should be parsed as a long type.
    list \
        [expr {" $min_long_str "}] \
        [expr {$min_long_str + 0}] \
        [expr {$min_long + 0}] \
        [expr {-2147483648 + 0}] \
        [expr {$min_long == $min_long_hex}] \
        [expr {(-2147483648 - 1) == 0x7FFFFFFF}] \

} {-2147483648 -2147483648 -2147483648 -2147483648 1 1}

test expr-33.3 {parse largest wide value} {wideis64bit} {
    set max_wide_str 9223372036854775807
    set max_wide_hex "0x7FFFFFFFFFFFFFFF "

    # Convert to wide integer
    set max_wide 9223372036854775807
    string is integer $max_wide

    list \
        [expr {" $max_wide_str "}] \
        [expr {$max_wide_str + 0}] \
        [expr {$max_wide + 0}] \
        [expr {9223372036854775807 + 0}] \
        [expr {$max_wide == $max_wide_hex}] \
        [expr {(9223372036854775807 + 1) < 0}] \

} {9223372036854775807 9223372036854775807 9223372036854775807 9223372036854775807 1 1}

test expr-33.4 {parse smallest wide value} {wideis64bit} {
    set min_wide_str -9223372036854775808
    set min_wide_hex "-0x8000000000000000 "

    set min_wide -9223372036854775808
    # Convert to wide integer
    string is integer $min_wide

    # Note: If the final expression returns 0 then the
    # wide integer is not being parsed correctly with
    # the leading - sign.
    list \
        [expr {" $min_wide_str "}] \
        [expr {$min_wide_str + 0}] \
        [expr {$min_wide + 0}] \
        [expr {-9223372036854775808 + 0}] \
        [expr {$min_wide == $min_wide_hex}] \
        [expr {(-9223372036854775808 - 1) == 0x7FFFFFFFFFFFFFFF}] \

} {-9223372036854775808 -9223372036854775808 -9223372036854775808 -9223372036854775808 1 1}

# 32 bit long integer tests

set min -2147483648
set max 2147483647

test expr-34.1 {expr edge cases} {longis32bit} {
    expr {$min / $min}
} {1}

test expr-34.2 {expr edge cases} {longis32bit} {
    expr {$min % $min}
} {0}

test expr-34.3 {expr edge cases} {longis32bit} {
    expr {$min / ($min + 1)}
} {1}

test expr-34.4 {expr edge cases} {longis32bit} {
    expr {$min % ($min + 1)}
} {-1}

test expr-34.5 {expr edge cases} {longis32bit} {
    expr {$min / ($min + 2)}
} {1}

test expr-34.6 {expr edge cases} {longis32bit} {
    expr {$min % ($min + 2)}
} {-2}

test expr-34.7 {expr edge cases} {longis32bit} {
    expr {$min / ($min + 3)}
} {1}

test expr-34.8 {expr edge cases} {longis32bit} {
    expr {$min % ($min + 3)}
} {-3}

test expr-34.9 {expr edge cases} {longis32bit} {
    expr {$min / -3}
} {715827882}

test expr-34.10 {expr edge cases} {longis32bit} {
    expr {$min % -3}
} {-2}

test expr-34.11 {expr edge cases} {longis32bit} {
    expr {$min / -2}
} {1073741824}

test expr-34.12 {expr edge cases} {longis32bit} {
    expr {$min % -2}
} {0}

test expr-34.13 {expr edge cases} {longis32bit} {
    expr {$min / -1}
} $min

test expr-34.14 {expr edge cases} {longis32bit} {
    expr {$min % -1}
} {0}

test expr-34.15 {expr edge cases} {longis32bit} {
    expr {$min * -1}
} $min

test expr-34.16 {expr edge cases} {longis32bit} {
    expr {-$min}
} $min

test expr-34.17 {expr edge cases} {longis32bit} {
    expr {$min / 1}
} $min

test expr-34.18 {expr edge cases} {longis32bit} {
    expr {$min % 1}
} {0}

test expr-34.19 {expr edge cases} {longis32bit} {
    expr {$min / 2}
} {-1073741824}

test expr-34.20 {expr edge cases} {longis32bit} {
    expr {$min % 2}
} {0}

test expr-34.21 {expr edge cases} {longis32bit} {
    expr {$min / 3}
} {-715827883}

test expr-34.22 {expr edge cases} {longis32bit} {
    expr {$min % 3}
} {1}

test expr-34.23 {expr edge cases} {longis32bit} {
    expr {$min / ($max - 3)}
} {-2}

test expr-34.24 {expr edge cases} {longis32bit} {
    expr {$min % ($max - 3)}
} {2147483640}

test expr-34.25 {expr edge cases} {longis32bit} {
    expr {$min / ($max - 2)}
} {-2}

test expr-34.26 {expr edge cases} {longis32bit} {
    expr {$min % ($max - 2)}
} {2147483642}

test expr-34.27 {expr edge cases} {longis32bit} {
    expr {$min / ($max - 1)}
} {-2}

test expr-34.28 {expr edge cases} {longis32bit} {
    expr {$min % ($max - 1)}
} {2147483644}

test expr-34.29 {expr edge cases} {longis32bit} {
    expr {$min / $max}
} {-2}

test expr-34.30 {expr edge cases} {longis32bit} {
    expr {$min % $max}
} {2147483646}

test expr-34.31 {expr edge cases} {longis32bit} {
    expr {$max / $max}
} {1}

test expr-34.32 {expr edge cases} {longis32bit} {
    expr {$max % $max}
} {0}

test expr-34.33 {expr edge cases} {longis32bit} {
    expr {$max / ($max - 1)}
} {1}

test expr-34.34 {expr edge cases} {longis32bit} {
    expr {$max % ($max - 1)}
} {1}

test expr-34.35 {expr edge cases} {longis32bit} {
    expr {$max / ($max - 2)}
} {1}

test expr-34.36 {expr edge cases} {longis32bit} {
    expr {$max % ($max - 2)}
} {2}

test expr-34.37 {expr edge cases} {longis32bit} {
    expr {$max / ($max - 3)}
} {1}

test expr-34.38 {expr edge cases} {longis32bit} {
    expr {$max % ($max - 3)}
} {3}

test expr-34.39 {expr edge cases} {longis32bit} {
    expr {$max / 3}
} {715827882}

test expr-34.40 {expr edge cases} {longis32bit} {
    expr {$max % 3}
} {1}

test expr-34.41 {expr edge cases} {longis32bit} {
    expr {$max / 2}
} {1073741823}

test expr-34.42 {expr edge cases} {longis32bit} {
    expr {$max % 2}
} {1}

test expr-34.43 {expr edge cases} {longis32bit} {
    expr {$max / 1}
} $max

test expr-34.44 {expr edge cases} {longis32bit} {
    expr {$max % 1}
} {0}

test expr-34.45 {expr edge cases} {longis32bit} {
    expr {$max / -1}
} "-$max"

test expr-34.46 {expr edge cases} {longis32bit} {
    expr {$max % -1}
} {0}

test expr-34.47 {expr edge cases} {longis32bit} {
    expr {$max / -2}
} {-1073741824}

test expr-34.48 {expr edge cases} {longis32bit} {
    expr {$max % -2}
} {-1}

test expr-34.49 {expr edge cases} {longis32bit} {
    expr {$max / -3}
} {-715827883}

test expr-34.50 {expr edge cases} {longis32bit} {
    expr {$max % -3}
} {-2}

test expr-34.51 {expr edge cases} {longis32bit} {
    expr {$max / ($min + 3)}
} {-2}

test expr-34.52 {expr edge cases} {longis32bit} {
    expr {$max % ($min + 3)}
} {-2147483643}

test expr-34.53 {expr edge cases} {longis32bit} {
    expr {$max / ($min + 2)}
} {-2}

test expr-34.54 {expr edge cases} {longis32bit} {
    expr {$max % ($min + 2)}
} {-2147483645}

test expr-34.55 {expr edge cases} {longis32bit} {
    expr {$max / ($min + 1)}
} {-1}

test expr-34.56 {expr edge cases} {longis32bit} {
    expr {$max % ($min + 1)}
} {0}

test expr-34.57 {expr edge cases} {longis32bit} {
    expr {$max / $min}
} {-1}

test expr-34.58 {expr edge cases} {longis32bit} {
    expr {$max % $min}
} {-1}

test expr-34.59 {expr edge cases} {longis32bit} {
    expr {($min + 1) / ($max - 1)}
} {-2}

test expr-34.60 {expr edge cases} {longis32bit} {
    expr {($min + 1) % ($max - 1)}
} {2147483645}

test expr-34.61 {expr edge cases} {longis32bit} {
    expr {($max - 1) / ($min + 1)}
} {-1}

test expr-34.62 {expr edge cases} {longis32bit} {
    expr {($max - 1) % ($min + 1)}
} {-1}

test expr-34.63 {expr edge cases} {longis32bit} {
    expr {($max - 1) / $min}
} {-1}

test expr-34.64 {expr edge cases} {longis32bit} {
    expr {($max - 1) % $min}
} {-2}

test expr-34.65 {expr edge cases} {longis32bit} {
    expr {($max - 2) / $min}
} {-1}

test expr-34.66 {expr edge cases} {longis32bit} {
    expr {($max - 2) % $min}
} {-3}

test expr-34.67 {expr edge cases} {longis32bit} {
    expr {($max - 3) / $min}
} {-1}

test expr-34.68 {expr edge cases} {longis32bit} {
    expr {($max - 3) % $min}
} {-4}

test expr-34.69 {expr edge cases} {longis32bit} {
    expr {-3 / $min}
} {0}

test expr-34.70 {expr edge cases} {longis32bit} {
    expr {-3 % $min}
} {-3}

test expr-34.71 {expr edge cases} {longis32bit} {
    expr {-2 / $min}
} {0}

test expr-34.72 {expr edge cases} {longis32bit} {
    expr {-2 % $min}
} {-2}

test expr-34.73 {expr edge cases} {longis32bit} {
    expr {-1 / $min}
} {0}

test expr-34.74 {expr edge cases} {longis32bit} {
    expr {-1 % $min}
} {-1}

test expr-34.75 {expr edge cases} {longis32bit} {
    expr {0 / $min}
} {0}

test expr-34.76 {expr edge cases} {longis32bit} {
    expr {0 % $min}
} {0}

test expr-34.77 {expr edge cases} {longis32bit} {
    expr {0 / ($min + 1)}
} {0}

test expr-34.78 {expr edge cases} {longis32bit} {
    expr {0 % ($min + 1)}
} {0}

test expr-34.79 {expr edge cases} {longis32bit} {
    expr {1 / $min}
} {-1}

test expr-34.80 {expr edge cases} {longis32bit} {
    expr {1 % $min}
} {-2147483647}

test expr-34.81 {expr edge cases} {longis32bit} {
    expr {1 / ($min + 1)}
} {-1}

test expr-34.82 {expr edge cases} {longis32bit} {
    expr {1 % ($min + 1)}
} {-2147483646}

test expr-34.83 {expr edge cases} {longis32bit} {
    expr {2 / $min}
} {-1}

test expr-34.84 {expr edge cases} {longis32bit} {
    expr {2 % $min}
} {-2147483646}

test expr-34.85 {expr edge cases} {longis32bit} {
    expr {2 / ($min + 1)}
} {-1}

test expr-34.86 {expr edge cases} {longis32bit} {
    expr {2 % ($min + 1)}
} {-2147483645}

test expr-34.87 {expr edge cases} {longis32bit} {
    expr {3 / $min}
} {-1}

test expr-34.88 {expr edge cases} {longis32bit} {
    expr {3 % $min}
} {-2147483645}

test expr-34.89 {expr edge cases} {longis32bit} {
    expr {3 / ($min + 1)}
} {-1}

test expr-34.90 {expr edge cases} {longis32bit} {
    expr {3 % ($min + 1)}
} {-2147483644}

# Euclidean property:
# quotient * divisor + remainder = dividend

test expr-35.1 {expr edge cases} {longis32bit} {
    set dividend $max
    set divisor 2
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($divisor * $q) + $r}]
} {1073741823 * 2 + 1 = 2147483647}

test expr-35.2 {expr edge cases} {longis32bit} {
    set dividend [expr {$max - 1}]
    set divisor 2
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {1073741823 * 2 + 0 = 2147483646}

test expr-35.3 {expr edge cases} {longis32bit} {
    set dividend [expr {$max - 2}]
    set divisor 2
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {1073741822 * 2 + 1 = 2147483645}

test expr-35.4 {expr edge cases} {longis32bit} {
    set dividend $max
    set divisor 3
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {715827882 * 3 + 1 = 2147483647}

test expr-35.5 {expr edge cases} {longis32bit} {
    set dividend [expr {$max - 1}]
    set divisor 3
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {715827882 * 3 + 0 = 2147483646}

test expr-35.6 {expr edge cases} {longis32bit} {
    set dividend [expr {$max - 2}]
    set divisor 3
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {715827881 * 3 + 2 = 2147483645}

test expr-35.7 {expr edge cases} {longis32bit} {
    set dividend $min
    set divisor 2
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {-1073741824 * 2 + 0 = -2147483648}

test expr-35.8 {expr edge cases} {longis32bit} {
    set dividend [expr {$min + 1}]
    set divisor 2
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {-1073741824 * 2 + 1 = -2147483647}

test expr-35.9 {expr edge cases} {longis32bit} {
    set dividend [expr {$min + 2}]
    set divisor 2
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {-1073741823 * 2 + 0 = -2147483646}

test expr-35.10 {expr edge cases} {longis32bit} {
    # Two things could happen here. The multiplication
    # could overflow a 32 bit type, so that when
    # 1 is added it overflows again back to min.
    # The multiplication could also use a wide type
    # to hold ($min - 1) until 1 is added and
    # the number becomes $min again.
    set dividend $min
    set divisor 3
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {-715827883 * 3 + 1 = -2147483648}

test expr-35.11 {expr edge cases} {longis32bit} {
    set dividend $min
    set divisor -3
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {715827882 * -3 + -2 = -2147483648}

test expr-35.12 {expr edge cases} {longis32bit} {
    set dividend $min
    set divisor $min
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {1 * -2147483648 + 0 = -2147483648}

test expr-35.13 {expr edge cases} {longis32bit} {
    set dividend $min
    set divisor [expr {$min + 1}]
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {1 * -2147483647 + -1 = -2147483648}

test expr-35.14 {expr edge cases} {longis32bit} {
    set dividend $min
    set divisor [expr {$min + 2}]
    set q [expr {$dividend / $divisor}]
    set r [expr {$dividend % $divisor}]
    list $q * $divisor + $r = [expr {($q * $divisor) + $r}]
} {1 * -2147483646 + -2 = -2147483648}


# Test series 36 and 37 are used for 64bit wide integer checks


test expr-38.1 {abs of smallest 32-bit integer [Bug 1241572]} {wideis64bit} {
    expr {abs(int(-2147483648))}
} 2147483648

test expr-46.1 {round() rounds to +-infinity} {
    expr round(0.5)
} 1
test expr-46.2 {round() rounds to +-infinity} {
    expr round(1.5)
} 2
test expr-46.3 {round() rounds to +-infinity} {
    expr round(-0.5)
} -1
test expr-46.4 {round() rounds to +-infinity} {
    expr round(-1.5)
} -2
test expr-46.5 {round() overflow} {
    list [catch {expr round(9.2233720368547758e+018)} result] $result
} {1 {integer value too large to represent}}
test expr-46.6 {round() overflow} {
    list [catch {expr round(-9.2233720368547758e+018)} result] $result
} {1 {integer value too large to represent}}
test expr-46.7 {round() bad value} {
    set x trash
    list [catch {expr {round($x)}} result] $result
} {1 {argument to math function didn't have numeric value}}
test expr-46.8 {round() already an integer} {wideis64bit} {
    set x 123456789012
    incr x
    expr round($x)
} 123456789013
test expr-46.9 {round() boundary case - 1/2 - 1 ulp} {
    set x 0.25
    set bit 0.125
    while 1 {
	set newx [expr {$x + $bit}]
	if { $newx == $x || $newx == 0.5 } break
	set x $newx
	set bit [expr { $bit / 2.0 }]
    }
    expr {round($x)}
} 0
test expr-46.10 {round() boundary case - 1/2 + 1 ulp} {
    set x 0.75
    set bit 0.125
    while 1 {
	set newx [expr { $x - $bit }]
	if { $newx == $x || $newx == 0.5 } break
	set x $newx
	set bit [expr { $bit / 2.0 }]
    }
    expr {round($x)}
} 1
test expr-46.11 {round() boundary case - -1/2 - 1 ulp} {
    set x -0.75
    set bit 0.125
    while 1 {
	set newx [expr { $x + $bit }]
	if { $newx == $x || $newx == -0.5 } break
	set x $newx
	set bit [expr { $bit / 2.0 }]
    }
    expr {round($x)}
} -1
test expr-46.12 {round() boundary case - -1/2 + 1 ulp} {
    set x -0.25
    set bit 0.125
    while 1 {
	set newx [expr { $x - $bit }]
	if { $newx == $x || $newx == -0.5 } break
	set x $newx
	set bit [expr { $bit / 2.0 }]
    }
    expr {round($x)}
} 0

test expr-46.13 {round() boundary case - largest int} {
    set imax [expr {((1<<31) + 1) * -1}]
    expr {round($imax - 0.51)}
} 2147483646

test expr-46.14 {round() boundary case - largest int} {
    set imax [expr {((1<<31) + 1) * -1}]
    expr {round($imax - 0.50)}
} 2147483647

test expr-46.15 {round() boundary case - int too large} {
    set imax [expr {((1<<31) + 1) * -1}]
    list [catch {expr {round($imax + 0.50)}} err] $err
} {1 {integer value too large to represent}}

test expr-46.16 {round() boundary case - smallest int} {
    set imin [expr {1<<31}]
    expr {round($imin + 0.51)}
} -2147483647

test expr-46.17 {round() boundary case - smallest int} {
    set imin [expr {1<<31}]
    expr {round($imin + 0.50)}
} -2147483648

test expr-46.18 {round() boundary case - int too large} {
    set imin [expr {1<<31}]
    list [catch {expr {round($imin - 0.50)}} err] $err
} {1 {integer value too large to represent}}


# cleanup
if {[info exists a]} {
    unset a
}
::tcltest::cleanupTests
return
