test_tjc_init

# Test series 9 checks inlined and
# optimized expr operations. These
# expr oprations are more easily
# inlined and should offer runtime
# execution speed improvements
# over the expr operations implemented
# as part of +inline-containers.
#
# This is enabled via the +inline-expr
# OPTIONS flag.

# Load jdk test data in case this has not already been done.
source [file join [tcltest::testsDirectory] jdkutils.tcl]
test_jdk_load_config

# Invoked after compileproc_init is invoked inside compileproc_compile.

proc test_compileproc_9_set_flags { proc_name } {
    global _compileproc
    global test_compileproc_9_inline_expr_operators
    global test_compileproc_9_stack_expr_value
    global test_compileproc_9_stack_expr_value_null

    # Inline all containers but don't bother caching commands.
    set _compileproc(options,inline_containers) {all}

    # Use inlined variables.
    set _compileproc(options,cache_variables) 1

    # Use inlined commands
    set _compileproc(options,inline_commands) 1
    set _compileproc(options,inline_controls) 1

    # Skip constant incr.
    set _compileproc(options,skip_constant_increment) 1

    # Omit unused results
    set _compileproc(options,omit_results) 1

    # Enable inline expr operators by default.

    if {![info exists test_compileproc_9_inline_expr_operators]} {
        set _compileproc(options,expr_inline_operators) 1
    } else {
        if {$test_compileproc_9_inline_expr_operators} {
            set _compileproc(options,expr_inline_operators) 1
        }
        unset test_compileproc_9_inline_expr_operators
    }

    # Don't enable stack expr flag by default, this
    # flag is only enabled when explicitly asked for.

    if {![info exists test_compileproc_9_stack_expr_value]} {
        set _compileproc(options,expr_value_stack) 0
    } else {
        if {$test_compileproc_9_stack_expr_value} {
            set _compileproc(options,expr_value_stack) 1
        }
        unset test_compileproc_9_stack_expr_value
    }

    # Don't enable special null debug flag by
    # default.

    if {![info exists test_compileproc_9_stack_expr_value_null]} {
        set _compileproc(options,expr_value_stack_null) 0
    } else {
        if {$test_compileproc_9_stack_expr_value_null} {
            set _compileproc(options,expr_value_stack_null) 1
        }
        unset test_compileproc_9_stack_expr_value_null
    }
}

tcltest::test compileproc9-1.0 {expr eq/ne operators, no +inline-expr} {
    set script {
proc p {} {
    expr {$v1 eq $v2}
    expr {$v1 ne $v2}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 eq $v2}
            // Binary operator: $v1 eq $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STREQ, tmp1, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {$v1 ne $v2}
            // Binary operator: $v1 ne $v2
            TclObject tmp4 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TclObject tmp6 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STRNEQ, tmp5, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.1 {expr eq/ne operators, enable +inline-expr} {
    # This example will inline string compare operations
    # for the eq an ne operators. These operators are
    # commonly used with TclObject arguments, so the
    # compiler provides an inlined implementation for
    # the case where both operands are TclObjects.
    # This avoids parsing the objects and does not
    # call the exprBinaryOperator() method.

    set script {
proc p {} {
    expr {$v1 eq $v2}
    expr {$v1 ne $v2}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 eq $v2}
            // Binary operator: $v1 eq $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            String tmp3 = tmp2.toString();
            boolean tmp4 = tmp1.equals(tmp3);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        { // Invoke: expr {$v1 ne $v2}
            // Binary operator: $v1 ne $v2
            TclObject tmp6 = getVarScalar(interp, "v1", compiledLocals, 0);
            String tmp7 = tmp6.toString();
            TclObject tmp8 = getVarScalar(interp, "v2", compiledLocals, 1);
            String tmp9 = tmp8.toString();
            boolean tmp10 = ! tmp7.equals(tmp9);
            ExprValue tmp11 = TJC.exprGetValue(interp, tmp10);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp11);
            TJC.exprReleaseValue(interp, tmp11);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.2 {expr eq/ne operators, enable +inline-expr} {
    # This example will string compare a TclObject to
    # an ExprValue. This need not create an ExprValue
    # for the left operand or invoke exprBinaryOperator().

    set script {
proc p {} {
    expr {$v eq 1}
    expr {$v ne 1}
    expr {1 eq $v}
    expr {1 ne $v}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v eq 1}
            // Binary operator: $v eq 1
            TclObject tmp0 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            ExprValue tmp2 = TJC.exprGetValue(interp, 1, null);
            boolean tmp3 = tmp1.equals(tmp2.getStringValue());
            tmp2.setIntValue(tmp3);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        { // Invoke: expr {$v ne 1}
            // Binary operator: $v ne 1
            TclObject tmp4 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp5 = tmp4.toString();
            ExprValue tmp6 = TJC.exprGetValue(interp, 1, null);
            boolean tmp7 = ! tmp5.equals(tmp6.getStringValue());
            tmp6.setIntValue(tmp7);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp6);
            TJC.exprReleaseValue(interp, tmp6);
        } // End Invoke: expr
        { // Invoke: expr {1 eq $v}
            // Binary operator: 1 eq $v
            ExprValue tmp8 = TJC.exprGetValue(interp, 1, null);
            TclObject tmp9 = getVarScalar(interp, "v", compiledLocals, 0);
            boolean tmp10 = tmp8.getStringValue().equals(tmp9.toString());
            tmp8.setIntValue(tmp10);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp8);
            TJC.exprReleaseValue(interp, tmp8);
        } // End Invoke: expr
        { // Invoke: expr {1 ne $v}
            // Binary operator: 1 ne $v
            ExprValue tmp11 = TJC.exprGetValue(interp, 1, null);
            TclObject tmp12 = getVarScalar(interp, "v", compiledLocals, 0);
            boolean tmp13 = ! tmp11.getStringValue().equals(tmp12.toString());
            tmp11.setIntValue(tmp13);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp11);
            TJC.exprReleaseValue(interp, tmp11);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.3 {expr eq/ne operators, enable +inline-expr} {
    # Compare a TclObject result from a command to an ExprValue.

    set script {
proc p {} {
    expr {[cmd] eq 1}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {[cmd] eq 1}
            // Binary operator: [...] eq 1
            { // Invoke: cmd
                TclObject[] objv0 = TJC.grabObjv(interp, 1);
                try {
                    // Arg 0 constant: cmd
                    objv0[0] = const0;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjv(interp, objv0, 1);
                }
            } // End Invoke: cmd
            TclObject tmp1 = interp.getResult();
            String tmp2 = tmp1.toString();
            ExprValue tmp3 = TJC.exprGetValue(interp, 1, null);
            boolean tmp4 = tmp2.equals(tmp3.getStringValue());
            tmp3.setIntValue(tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc9-1.4 {expr eq/ne operators, enable +inline-expr} {
    # This example shows the same variable getting queried twice.
    # The logic must query and save the String value of the left
    # operand before getting the String value of the right operand
    # because of tricky var trace edge cases.
    set script {
proc p {} {
    expr {$v eq $v}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v eq $v}
            // Binary operator: $v eq $v
            TclObject tmp0 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp3 = tmp2.toString();
            boolean tmp4 = tmp1.equals(tmp3);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.5 {expr eq/ne operators, enable +inline-expr} {
    # When both operands are type ExprValue, then
    # the exprBinaryOperator() method is invoked.

    set script {
proc p {} {
    expr {255 eq -0xFF}
    expr {(1 + 0) ne 1}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {255 eq -0xFF}
            // Binary operator: 255 eq ()
            ExprValue tmp0 = TJC.exprGetValue(interp, 255, null);
            // Unary operator: - 255
            ExprValue tmp1 = TJC.exprGetValue(interp, -255, null);
            // End Unary operator: -
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STREQ, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {(1 + 0) ne 1}
            // Binary operator: () ne 1
            // Binary operator: 1 + 0
            ExprValue tmp2 = TJC.exprGetValue(interp, 1, null);
            ExprValue tmp3 = TJC.exprGetValue(interp, 0, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp2, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: +
            ExprValue tmp4 = TJC.exprGetValue(interp, 1, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STRNEQ, tmp2, tmp4);
            TJC.exprReleaseValue(interp, tmp4);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-1.6 {expr eq/ne operators, enable +inline-expr} {

    set script {
proc p {} {
    expr {$v eq int($v)}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v eq int($v)}
            // Binary operator: $v eq math()
            TclObject tmp0 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            // Math function: int $v
            TclObject tmp2 = getVarScalar(interp, "v", compiledLocals, 0);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprIntMathFunction(interp, tmp3);
            // End Math function: int
            boolean tmp4 = tmp1.equals(tmp3.getStringValue());
            tmp3.setIntValue(tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.7 {expr ==/!= operators, no +inline-expr} {
    set script {
proc p {} {
    expr {$v1 == $v2}
    expr {$v1 != $v2}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 == $v2}
            // Binary operator: $v1 == $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp1, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {$v1 != $v2}
            // Binary operator: $v1 != $v2
            TclObject tmp4 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TclObject tmp6 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_NEQ, tmp5, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
            // End Binary operator: !=
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.8 {expr ==/!= operators, enable +inline-expr} {
    # Only the eq and ne operators are currently inlined
    # by +inline-expr.
    set script {
proc p {} {
    expr {$v1 == $v2}
    expr {$v1 != $v2}
}
}

    set test_compileproc_9_inline_expr_operators 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 == $v2}
            // Binary operator: $v1 == $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp1, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {$v1 != $v2}
            // Binary operator: $v1 != $v2
            TclObject tmp4 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TclObject tmp6 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_NEQ, tmp5, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
            // End Binary operator: !=
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}


tcltest::test compileproc9-2.0 {expr logical not operator, no +inline-expr} {
    set script {
proc p {} {
    expr {!0}
    expr {!1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {!0}
            // Unary operator: ! 0
            ExprValue tmp0 = TJC.exprGetValue(interp, 0, null);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_NOT, tmp0);
            // End Unary operator: !
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {!1}
            // Unary operator: ! 1
            ExprValue tmp1 = TJC.exprGetValue(interp, 1, null);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_NOT, tmp1);
            // End Unary operator: !
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}


# Test series 3 checks the stack expr value functionality
# enabled via +inline-expr. This feature grabs
# ExprValue objects and saves them on the stack
# at the beginning of a compiled method implementation.
# This feature is performance critical because profiling
# indicates that grabbing and releasing ExprValue objects
# takes up most of the time in an expr evaluation. It
# does no good to allocate new ExprValue objects since
# hotspot is not bright enough to allocate them on the stack.

tcltest::test compileproc9-3.0 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {0 == 1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {0 == 1}
            // Binary operator: 0 == 1
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(0);
            ExprValue tmp1 = evs1;
            tmp1.setIntValue(1);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp0, tmp1);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.1 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {!0}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {!0}
            // Unary operator: ! 0
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(0);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_NOT, tmp0);
            // End Unary operator: !
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.2 {no +inline-expr, expr value on stack} {
    # This test is like 3.0, except that it enables a
    # special debug mode that will set the ExprValue
    # ref on the stack to null so that a NPE is
    # generated at runtime if a value is used twice.
    set script {
proc p {} {
    expr {0 == 1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set test_compileproc_9_stack_expr_value_null 1

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {0 == 1}
            // Binary operator: 0 == 1
            ExprValue tmp0 = evs0;
            evs0 = null;
            tmp0.setIntValue(0);
            ExprValue tmp1 = evs1;
            evs1 = null;
            tmp1.setIntValue(1);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp0, tmp1);
            evs1 = tmp1;
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp0);
            evs0 = tmp0;
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            if ( evs1 != null ) { TJC.exprReleaseValue(interp, evs1); }
            if ( evs0 != null ) { TJC.exprReleaseValue(interp, evs0); }
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.3 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {1 ? 0 : 1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set test_compileproc_9_stack_expr_value_null 1

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {1 ? 0 : 1}
            // Ternary operator: 1 ? 0 : 1
            ExprValue tmp0 = evs0;
            evs0 = null;
            tmp0.setIntValue(1);
            if (tmp0.getBooleanValue(interp)) {
            ExprValue tmp1 = evs1;
            evs1 = null;
            tmp1.setIntValue(0);
            tmp0.setValue(tmp1);
            evs1 = tmp1;
            } else {
            ExprValue tmp2 = evs1;
            evs1 = null;
            tmp2.setIntValue(1);
            tmp0.setValue(tmp2);
            evs1 = tmp2;
            }
            // End Ternary operator: ?
            TJC.exprSetResult(interp, tmp0);
            evs0 = tmp0;
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            if ( evs1 != null ) { TJC.exprReleaseValue(interp, evs1); }
            if ( evs0 != null ) { TJC.exprReleaseValue(interp, evs0); }
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.4 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {1 && 1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {1 && 1}
            // Binary operator: 1 && 1
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(1);
            if (tmp0.getBooleanValue(interp)) {
            ExprValue tmp1 = evs1;
            tmp1.setIntValue(1);
            tmp0.setIntValue(tmp1.getBooleanValue(interp));
            } else {
            tmp0.setIntValue(0);
            } // End if: 1
            // End Binary operator: &&
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.5 {no +inline-expr, expr value on stack} {
# FIXME: Would it be possible to use just 1 ExprValue when
# doing the evaluation of a logical || OR like this?
# The second result seems to just be asssigned in the first,
# so why not use the same value and avoid the asssign?

    set script {
proc p {} {
    expr {0 || 1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {0 || 1}
            // Binary operator: 0 || 1
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(0);
            if (!tmp0.getBooleanValue(interp)) {
            ExprValue tmp1 = evs1;
            tmp1.setIntValue(1);
            tmp0.setIntValue(tmp1.getBooleanValue(interp));
            } else {
            tmp0.setIntValue(1);
            } // End if: !0
            // End Binary operator: ||
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.6 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    set obj 1
    if {$obj} {}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set obj 1
            setVarScalar(interp, "obj", const0, compiledLocals, 0);
        } // End Invoke: set
        { // Invoke: if {$obj} {}
            TclObject tmp0 = getVarScalar(interp, "obj", compiledLocals, 0);
            boolean tmp1 = TJC.getBoolean(interp, tmp0);
            if ( tmp1 ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "obj"
    };
} // end class Test1
}}

tcltest::test compileproc9-3.7 {no +inline-expr, expr value on stack} {
    # This example shows a tricky case where more than 2
    # expr values are allocated because a nested operand
    # contains an expr command.
    set script {
proc p {} {
    expr {1 + [expr {2 + 3}]}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        ExprValue evs2 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {1 + [expr {2 + 3}]}
            // Binary operator: 1 + [...]
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(1);
            { // Invoke: expr {2 + 3}
                // Binary operator: 2 + 3
                ExprValue tmp1 = evs1;
                tmp1.setIntValue(2);
                ExprValue tmp2 = evs2;
                tmp2.setIntValue(3);
                TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp1, tmp2);
                // End Binary operator: +
                TJC.exprSetResult(interp, tmp1);
            } // End Invoke: expr
            TclObject tmp3 = interp.getResult();
            ExprValue tmp4 = evs1;
            TJC.exprInitValue(interp, tmp4, tmp3);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp4);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs2);
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.8 {no +inline-expr, expr value on stack} {
    # This test shows that subexpression evaluation
    # does not reuse expr value objects when
    # processing subexpressions. This is not
    # optimal, but it may be possible to
    # work around this issue for expressions
    # with constant values.
    set script {
proc p {} {
    expr {1 + (2 + 3)}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        ExprValue evs2 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {1 + (2 + 3)}
            // Binary operator: 1 + ()
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(1);
            // Binary operator: 2 + 3
            ExprValue tmp1 = evs1;
            tmp1.setIntValue(2);
            ExprValue tmp2 = evs2;
            tmp2.setIntValue(3);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp1, tmp2);
            // End Binary operator: +
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp1);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs2);
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.10 {no +inline-expr, expr value on stack} {
    # This test shows that complex subexpression
    # will need at most 3 expr values.
    set script {
proc p {} {
    expr {(1 + 2) + (3 + 4) + (5 + 6)}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        ExprValue evs2 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr ...
            // Binary operator: () + ()
            // Binary operator: () + ()
            // Binary operator: 1 + 2
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(1);
            ExprValue tmp1 = evs1;
            tmp1.setIntValue(2);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp1);
            // End Binary operator: +
            // Binary operator: 3 + 4
            ExprValue tmp2 = evs1;
            tmp2.setIntValue(3);
            ExprValue tmp3 = evs2;
            tmp3.setIntValue(4);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp2, tmp3);
            // End Binary operator: +
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp2);
            // End Binary operator: +
            // Binary operator: 5 + 6
            ExprValue tmp4 = evs1;
            tmp4.setIntValue(5);
            ExprValue tmp5 = evs2;
            tmp5.setIntValue(6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp4, tmp5);
            // End Binary operator: +
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp4);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs2);
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.11 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {-1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {-1}
            // Unary operator: - 1
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(-1);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.12 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {0 + -1}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {0 + -1}
            // Binary operator: 0 + ()
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(0);
            // Unary operator: - 1
            ExprValue tmp1 = evs1;
            tmp1.setIntValue(-1);
            // End Unary operator: -
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp1);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.13 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {pow(2,2)}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        ExprValue evs1 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {pow(2,2)}
            // Math function: pow 2 2
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(2);
            ExprValue tmp1 = evs1;
            tmp1.setIntValue(2);
            ExprValue[] tmp2 = new ExprValue[2];
            tmp2[0] = tmp0;
            tmp2[1] = tmp1;
            TJC.exprMathFunction(interp, "pow", tmp2, null);
            // End Math function: pow
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs1);
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.14 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {sqrt(121)}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {sqrt(121)}
            // Math function: sqrt 121
            ExprValue tmp0 = evs0;
            tmp0.setIntValue(121);
            ExprValue[] tmp1 = new ExprValue[1];
            tmp1[0] = tmp0;
            TJC.exprMathFunction(interp, "sqrt", tmp1, null);
            // End Math function: sqrt
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.15 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {rand()}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {rand()}
            // Math function: rand
            ExprValue tmp0 = evs0;
            TJC.exprMathFunction(interp, "rand", null, tmp0);
            // End Math function: rand
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.16 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {$obj == ""}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        ExprValue evs0 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$obj == ""}
            // Binary operator: $obj == ""
            TclObject tmp0 = getVarScalar(interp, "obj", compiledLocals, 0);
            ExprValue tmp1 = evs0;
            TJC.exprEqualsEmptyString(tmp1, tmp0, false);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "obj"
    };
} // end class Test1
}}

tcltest::test compileproc9-3.17 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {""}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {""}
            ExprValue tmp0 = evs0;
            tmp0.setStringValue("");
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-3.18 {no +inline-expr, expr value on stack} {
    set script {
proc p {} {
    expr {1.0}
}
}

    set test_compileproc_9_inline_expr_operators 0
    set test_compileproc_9_stack_expr_value 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        ExprValue evs0 = TJC.exprGetValue(interp);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {1.0}
            ExprValue tmp0 = evs0;
            tmp0.setDoubleValue(1.0);
            TJC.exprSetResult(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.exprReleaseValue(interp, evs0);
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}


# Cleanup
jdk_tool_cleanup
tcltest::cleanupTests

